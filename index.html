<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>AR Floorplan · Anchored</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400&family=Syne:wght@700;800&display=swap" rel="stylesheet">
<style>
* { margin:0; padding:0; box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
:root {
  --ink:#04050f; --paper:#e8e4db; --accent:#e84f2b;
  --green:#2be87a; --blue:#4da6ff; --yellow:#f0d060;
  --mono:'Space Mono',monospace;
  --display:'Syne',sans-serif;
}
html,body { height:100%; overflow:hidden; background:var(--ink); color:var(--paper); font-family:var(--mono); }

/* ── LANDING ── */
#landing {
  position:fixed; inset:0; display:flex; flex-direction:column;
  align-items:center; justify-content:center; padding:24px;
  background:var(--ink); z-index:100; overflow-y:auto;
}

/* Animated grid background */
#landing::before {
  content:''; position:absolute; inset:0; z-index:0;
  background-image:
    linear-gradient(rgba(232,79,43,.06) 1px, transparent 1px),
    linear-gradient(90deg, rgba(232,79,43,.06) 1px, transparent 1px);
  background-size:48px 48px;
  animation:gridDrift 18s linear infinite;
}
#landing::after {
  content:''; position:absolute; inset:0; z-index:0;
  background: radial-gradient(ellipse 70% 60% at 50% 50%, rgba(232,79,43,.08) 0%, transparent 70%),
              radial-gradient(ellipse 40% 40% at 15% 80%, rgba(77,166,255,.06) 0%, transparent 60%),
              radial-gradient(ellipse 50% 40% at 85% 20%, rgba(43,232,122,.05) 0%, transparent 60%);
  pointer-events:none;
}
@keyframes gridDrift { from{background-position:0 0} to{background-position:48px 48px} }

.landing-inner {
  position:relative; z-index:1; width:100%; max-width:520px;
  display:flex; flex-direction:column; align-items:center;
}

/* Top nav bar */
.l-nav {
  width:100%; display:flex; align-items:center; justify-content:space-between;
  margin-bottom:52px; border-bottom:1px solid rgba(232,79,43,.2); padding-bottom:14px;
}
.l-logo {
  font-family:var(--display); font-size:13px; font-weight:800; letter-spacing:.06em;
  color:var(--paper); text-transform:uppercase;
}
.l-logo span { color:var(--accent); }
.l-badge {
  font-size:9px; letter-spacing:.3em; text-transform:uppercase;
  padding:4px 10px; border:1px solid rgba(43,232,122,.4); color:var(--green);
  border-radius:100px; background:rgba(43,232,122,.06);
  animation:badgePulse 2.4s ease-in-out infinite;
}
@keyframes badgePulse { 0%,100%{opacity:.6} 50%{opacity:1} }

/* Main headline */
.l-headline {
  font-family:var(--display); font-weight:800;
  font-size:clamp(36px,10vw,72px); line-height:.9;
  text-align:center; letter-spacing:-.02em;
  margin-bottom:10px;
  animation:fadeUp .7s cubic-bezier(.16,1,.3,1) both;
}
.l-headline .line2 { display:block; color:var(--accent); font-style:italic; }
@keyframes fadeUp { from{opacity:0;transform:translateY(20px)} to{opacity:1;transform:translateY(0)} }

.l-sub {
  font-size:11px; letter-spacing:.18em; text-transform:uppercase;
  color:rgba(232,228,219,.38); margin-bottom:36px;
  animation:fadeUp .7s .12s cubic-bezier(.16,1,.3,1) both;
}

/* Feature tags */
.l-tags {
  display:flex; gap:8px; flex-wrap:wrap; justify-content:center;
  margin-bottom:36px;
  animation:fadeUp .7s .22s cubic-bezier(.16,1,.3,1) both;
}
.l-tag {
  font-size:9px; letter-spacing:.22em; text-transform:uppercase;
  padding:5px 12px; border-radius:100px;
  border:1px solid rgba(255,255,255,.1); color:rgba(232,228,219,.5);
  background:rgba(255,255,255,.03);
}
.l-tag.hi { border-color:rgba(77,166,255,.35); color:var(--blue); background:rgba(77,166,255,.06); }

/* Drop zone */
.drop-zone {
  width:100%; border:1px solid rgba(232,79,43,.25);
  background:rgba(232,79,43,.03);
  border-radius:4px; padding:28px 20px; text-align:center; cursor:pointer;
  transition:border-color .2s, background .2s, box-shadow .2s;
  position:relative; overflow:hidden;
  animation:fadeUp .7s .32s cubic-bezier(.16,1,.3,1) both;
}
.drop-zone::before {
  content:''; position:absolute; inset:0;
  background:linear-gradient(135deg, transparent 40%, rgba(232,79,43,.04) 100%);
  pointer-events:none;
}
.drop-zone:hover, .drop-zone.over {
  border-color:var(--accent); background:rgba(232,79,43,.07);
  box-shadow:0 0 32px rgba(232,79,43,.12), inset 0 0 24px rgba(232,79,43,.04);
}
.drop-icon { font-size:28px; display:block; margin-bottom:9px; filter:grayscale(.4); }
.drop-label { font-size:11px; letter-spacing:.22em; text-transform:uppercase; margin-bottom:5px; color:var(--paper); }
.drop-sub { font-size:10px; color:rgba(232,228,219,.32); letter-spacing:.1em; }
#fileInput { display:none; }

/* Thumb preview */
#pdfThumb {
  display:none; margin-top:14px; max-width:100%; max-height:110px;
  border:1px solid rgba(255,255,255,.1); border-radius:2px;
}
#pageNav { display:none; align-items:center; gap:12px; margin-top:8px; font-size:11px; }
.pg-btn {
  background:none; border:1px solid rgba(255,255,255,.2); color:var(--paper);
  width:28px; height:28px; cursor:pointer; font-size:15px; font-family:var(--mono);
  border-radius:2px; transition:border-color .15s, color .15s;
}
.pg-btn:hover { border-color:var(--accent); color:var(--accent); }

/* Launch button */
#launchBtn {
  display:none; margin-top:18px; position:relative; overflow:hidden;
  background:var(--accent); color:#fff;
  border:none; padding:16px 48px; font-family:var(--mono); font-size:11px;
  letter-spacing:.32em; text-transform:uppercase; cursor:pointer;
  border-radius:2px; transition:background .2s, box-shadow .2s;
  animation:fadeUp .5s .4s cubic-bezier(.16,1,.3,1) both;
}
#launchBtn::after {
  content:''; position:absolute; inset:0;
  background:linear-gradient(90deg, transparent, rgba(255,255,255,.15), transparent);
  transform:translateX(-100%); transition:transform .5s;
}
#launchBtn:hover::after { transform:translateX(100%); }
#launchBtn.show { display:block; }
#launchBtn:hover { background:#c83d1e; box-shadow:0 0 28px rgba(232,79,43,.35); }

.note {
  margin-top:14px; font-size:10px; color:rgba(232,228,219,.2);
  letter-spacing:.07em; text-align:center; max-width:380px; line-height:1.9;
  animation:fadeUp .7s .45s cubic-bezier(.16,1,.3,1) both;
}
#errMsg { display:none; margin-top:10px; font-size:11px; color:var(--accent); letter-spacing:.08em; }

/* ── AR SCREEN ── */
#arScreen { display:none; position:fixed; inset:0; z-index:200; background:#000; }
#arCanvas { width:100%; height:100%; display:block; }

/* ── DOM OVERLAY ROOT — covers full screen, is the XR dom-overlay root ── */
/* Everything the user needs to interact with in AR lives inside #xrOverlay */
#xrOverlay {
  position:fixed; inset:0; z-index:300;
  pointer-events:none;   /* children opt-in with pointer-events:all */
}

/* ── HUD ── */
#hud {
  position:absolute; bottom:0; left:0; right:0; padding:10px 12px 34px;
  display:flex; flex-direction:column; align-items:center; gap:8px;
  pointer-events:none;
}
#hudHint {
  font-size:11px; letter-spacing:.15em; text-transform:uppercase;
  color:rgba(255,255,255,.9); background:rgba(0,0,0,.72);
  backdrop-filter:blur(12px); -webkit-backdrop-filter:blur(12px);
  padding:8px 16px; border-radius:100px; border:1px solid rgba(255,255,255,.12);
  max-width:93vw; text-align:center; line-height:1.6;
}
#statusBar {
  display:none; font-size:9px; letter-spacing:.1em; font-family:var(--mono);
  color:rgba(255,255,255,.7); background:rgba(0,0,0,.65);
  backdrop-filter:blur(8px); -webkit-backdrop-filter:blur(8px);
  padding:6px 14px; border-radius:8px; border:1px solid rgba(255,255,255,.08);
  white-space:pre; line-height:1.7; text-align:left; max-width:96vw;
  pointer-events:none;
}
.slider-row { display:flex; align-items:center; gap:7px; pointer-events:all; }
.sl-lbl { font-size:10px; letter-spacing:.13em; color:rgba(255,255,255,.42); min-width:44px; }
input[type=range] { -webkit-appearance:none; width:96px; height:2px; background:rgba(255,255,255,.18); border-radius:1px; outline:none; }
input[type=range]::-webkit-slider-thumb { -webkit-appearance:none; width:16px; height:16px; border-radius:50%; background:var(--accent); cursor:pointer; }
.btn-row { display:flex; gap:6px; pointer-events:all; flex-wrap:wrap; justify-content:center; }
.hud-btn {
  background:rgba(8,8,16,.82); backdrop-filter:blur(12px); -webkit-backdrop-filter:blur(12px);
  border:1px solid rgba(255,255,255,.14); color:#fff;
  padding:9px 13px; font-family:var(--mono); font-size:10px;
  letter-spacing:.11em; text-transform:uppercase; cursor:pointer;
  border-radius:2px; transition:background .15s, border-color .15s, color .15s;
}
.hud-btn:active { transform:scale(.95); }
.hud-btn:hover  { background:rgba(232,79,43,.18); border-color:var(--accent); }
.hud-btn.g  { background:rgba(43,232,122,.16); border-color:var(--green); color:var(--green); }
.hud-btn.b  { background:rgba(77,166,255,.16); border-color:var(--blue); color:var(--blue); }
.hud-btn.y  { background:rgba(240,208,96,.16); border-color:var(--yellow); color:var(--yellow); }
.hud-btn.r  { border-color:rgba(232,79,43,.4); }

/* Badges — inside xrOverlay */
#scanRing { display:none; position:absolute; left:50%; top:40%; transform:translate(-50%,-50%); pointer-events:none; }
#scanRing svg { animation:pulse 1.4s ease-in-out infinite; }
@keyframes pulse { 0%,100%{opacity:.3;transform:scale(.88)} 50%{opacity:1;transform:scale(1.05)} }

#snapReticle { display:none; position:absolute; left:50%; top:40%; transform:translate(-50%,-50%); pointer-events:none; }
#snapIndicator {
  display:none; position:absolute; top:18px; left:50%; transform:translateX(-50%);
  font-size:10px; letter-spacing:.22em; text-transform:uppercase; white-space:nowrap;
  padding:5px 16px; border-radius:100px;
  border:1px solid var(--green); color:var(--green); background:rgba(43,232,122,.12);
}
#cornerBadge {
  display:none; position:absolute; top:18px; left:50%; transform:translateX(-50%);
  font-size:11px; letter-spacing:.2em; text-transform:uppercase; white-space:nowrap;
  padding:6px 16px; border-radius:100px;
  background:rgba(77,166,255,.12); border:1px solid var(--blue); color:var(--blue);
}
#planeBadge {
  display:none; position:absolute; top:18px; right:14px;
  font-size:10px; letter-spacing:.18em; text-transform:uppercase; white-space:nowrap;
  padding:5px 12px; border-radius:100px;
  background:rgba(43,232,122,.1); border:1px solid var(--green); color:var(--green);
}
#driftBadge {
  display:none; position:absolute; top:52px; right:14px;
  font-size:10px; letter-spacing:.14em; text-transform:uppercase; white-space:nowrap;
  padding:4px 10px; border-radius:100px;
  background:rgba(240,208,96,.08); border:1px solid var(--yellow); color:var(--yellow);
}
#toast {
  display:none; position:absolute; top:54px; left:50%; transform:translateX(-50%);
  background:rgba(0,0,0,.86); backdrop-filter:blur(10px); -webkit-backdrop-filter:blur(10px);
  border:1px solid rgba(255,255,255,.1); padding:9px 22px;
  font-size:11px; letter-spacing:.11em; color:#fff; border-radius:100px; white-space:nowrap;
}

/* Measurement label floating in 3D space (projected to screen) */
#measureLabel {
  display:none; position:absolute; pointer-events:none;
  background:rgba(240,208,96,.92); color:#080810;
  font-size:11px; font-weight:700; letter-spacing:.12em;
  padding:5px 13px; border-radius:100px;
  transform:translate(-50%,-50%);
  box-shadow:0 2px 12px rgba(0,0,0,.4);
}

/* ── PICK OVERLAY ── */
#pickOverlay {
  display:none; position:absolute; inset:0;
  background:rgba(0,0,0,.94);
  flex-direction:column; align-items:center; justify-content:center;
  pointer-events:all;
}
#pickOverlay.show { display:flex; }
#pickTitle { font-size:11px; letter-spacing:.28em; text-transform:uppercase; color:var(--accent); margin-bottom:6px; text-align:center; padding:0 16px; }
#pickSub   { font-size:11px; color:rgba(240,237,228,.42); letter-spacing:.1em; margin-bottom:8px; text-align:center; padding:0 20px; line-height:1.6; }
#pickCanvas { max-width:96vw; max-height:52vh; cursor:crosshair; touch-action:none; border:1px solid rgba(255,255,255,.1); display:block; }
#pickInfo  { font-size:10px; letter-spacing:.16em; color:var(--blue); margin-top:7px; }
.pick-btns { display:flex; gap:9px; margin-top:10px; flex-wrap:wrap; justify-content:center; }
.pick-btn {
  background:rgba(8,8,16,.88); border:1px solid rgba(255,255,255,.2); color:var(--paper);
  padding:10px 18px; font-family:var(--mono); font-size:11px; letter-spacing:.17em;
  text-transform:uppercase; cursor:pointer; border-radius:2px;
}
.pick-btn.confirm { background:var(--accent); border-color:var(--accent); }
.pick-btn.confirm:disabled { background:#444; border-color:#444; cursor:not-allowed; color:#777; }
.pick-btn.ruler-active { background:rgba(240,208,96,.18); border-color:var(--yellow); color:var(--yellow); }

/* Scale ruler overlay inside pickOverlay */
#rulerPanel {
  display:none; width:100%; max-width:96vw; align-items:center;
  justify-content:center; gap:8px; margin-top:6px; flex-wrap:wrap;
}
#rulerPanel.show { display:flex; }
#rulerDistInput {
  background:rgba(0,0,0,.6); border:1px solid rgba(240,208,96,.5); color:var(--yellow);
  font-family:var(--mono); font-size:12px; padding:7px 10px; width:90px;
  border-radius:2px; outline:none; text-align:center;
}
#rulerDistInput::placeholder { color:rgba(240,208,96,.3); }
#rulerConfirmBtn {
  background:rgba(240,208,96,.15); border:1px solid var(--yellow); color:var(--yellow);
  padding:8px 14px; font-family:var(--mono); font-size:10px; letter-spacing:.15em;
  text-transform:uppercase; cursor:pointer; border-radius:2px;
}
#rulerConfirmBtn:disabled { opacity:.35; cursor:not-allowed; }
#rulerStatus { font-size:10px; letter-spacing:.12em; color:rgba(240,208,96,.65); }

/* ── GPS / COMPASS HUD PANEL ── */
#gpsPanel {
  position:absolute; top:14px; left:14px;
  display:none; flex-direction:column; gap:5px;
  pointer-events:all; z-index:10;
}
#gpsPanel.show { display:flex; }
#gpsBadge {
  display:flex; align-items:center; gap:7px;
  background:rgba(4,5,15,.88); backdrop-filter:blur(12px);
  border:1px solid rgba(255,255,255,.1); border-radius:6px;
  padding:7px 11px; min-width:180px;
}
#gpsAccDot {
  width:8px; height:8px; border-radius:50%; flex-shrink:0;
  background:var(--green); box-shadow:0 0 6px var(--green);
  transition:background .4s, box-shadow .4s;
}
#gpsAccDot.yellow { background:var(--yellow); box-shadow:0 0 6px var(--yellow); }
#gpsAccDot.red    { background:var(--accent);  box-shadow:0 0 6px var(--accent); }
#gpsText { font-size:9px; letter-spacing:.1em; line-height:1.7; color:rgba(232,228,219,.6); }
#gpsText strong { color:var(--paper); letter-spacing:.04em; display:block; }
#compassBadge {
  display:flex; align-items:center; gap:8px;
  background:rgba(4,5,15,.88); backdrop-filter:blur(12px);
  border:1px solid rgba(255,255,255,.1); border-radius:6px;
  padding:6px 11px;
}
#compassRose { width:28px; height:28px; flex-shrink:0; }
#compassRose svg { display:block; transition:transform .25s ease; }
#compassText { font-size:9px; letter-spacing:.1em; color:rgba(232,228,219,.6); line-height:1.7; }
#compassText strong { color:var(--paper); display:block; }
#gpsDriftBadge {
  display:none; align-items:center; gap:6px;
  background:rgba(4,5,15,.88); backdrop-filter:blur(12px);
  border-radius:6px; padding:6px 11px; border:1px solid rgba(255,255,255,.1);
  font-size:9px; letter-spacing:.11em; line-height:1.6; color:var(--paper);
}
#gpsDriftBadge.show { display:flex; }
#gpsDriftBadge.ok   { border-color:rgba(43,232,122,.4); color:var(--green); }
#gpsDriftBadge.warn { border-color:rgba(240,208,96,.4); color:var(--yellow); }
#gpsDriftBadge.bad  { border-color:rgba(232,79,43,.5);  color:var(--accent); }
.wp-label {
  position:absolute; pointer-events:none; white-space:nowrap;
  background:rgba(77,166,255,.92); color:#04050f;
  font-size:9px; font-weight:700; letter-spacing:.1em;
  padding:3px 9px; border-radius:100px;
  transform:translate(-50%,-140%);
  box-shadow:0 2px 8px rgba(0,0,0,.5);
}
#gpsMap {
  display:none; position:absolute; bottom:160px; right:14px;
  width:140px; height:140px;
  background:rgba(4,5,15,.92); backdrop-filter:blur(10px);
  border:1px solid rgba(77,166,255,.25); border-radius:6px;
  overflow:hidden; pointer-events:none;
}
#gpsMap.show { display:block; }
#gpsMapCanvas { width:140px; height:140px; display:block; }
#gpsMapLabel {
  position:absolute; bottom:4px; left:0; right:0; text-align:center;
  font-size:8px; letter-spacing:.15em; color:rgba(77,166,255,.45); text-transform:uppercase;
}
#gpsBtns { display:none; }
#gpsBtns.show { display:flex; }

</style>

</head>
<body>

<!-- LANDING (not inside xrOverlay — only shown before AR starts) -->
<div id="landing">
  <div class="landing-inner">
    <nav class="l-nav">
      <div class="l-logo"><span>AR</span>floor</div>
      <div class="l-badge">&#x25CF; WebXR Live</div>
    </nav>

    <h1 class="l-headline">
      Structure-locked
      <span class="line2">Floorplan AR.</span>
    </h1>
    <p class="l-sub">Anchored &middot; Drift-corrected &middot; Real-time</p>

    <div class="l-tags">
      <span class="l-tag hi">Hit-test</span>
      <span class="l-tag hi">Plane detection</span>
      <span class="l-tag hi">XR Anchors</span>
      <span class="l-tag">Scale ruler</span>
      <span class="l-tag">Measurement</span>
      <span class="l-tag">PDF overlay</span>
    </div>

    <div class="drop-zone" id="dropZone">
      <span class="drop-icon">&#x1F4C4;</span>
      <p class="drop-label">Drop floorplan PDF or tap to browse</p>
      <p class="drop-sub">Plane wireframes &middot; snap to edges &middot; drift-corrected anchors</p>
      <input type="file" id="fileInput" accept=".pdf,application/pdf">
      <canvas id="pdfThumb"></canvas>
      <div id="pageNav">
        <button class="pg-btn" id="prevPg">&#8249;</button>
        <span id="pgInfo">1 / 1</span>
        <button class="pg-btn" id="nextPg">&#8250;</button>
      </div>
    </div>
    <div id="errMsg"></div>
    <button id="launchBtn">Launch AR &rarr;</button>
    <p class="note">
      Scan ground &rarr; wireframes on detected surfaces &middot; Tap Anchor &rarr; walk to each column<br>
      (snaps to column edges) &rarr; set scale &rarr; pick columns on PDF &rarr; plan binds live
    </p>
  </div>
</div>

<!-- AR SCREEN -->
<div id="arScreen">
  <canvas id="arCanvas"></canvas>

  <!-- ═══════════════════════════════════════════════════════
       #xrOverlay is the dom-overlay root for WebXR.
       EVERYTHING the user sees/taps in AR must live here.
       ═══════════════════════════════════════════════════════ -->
  <div id="xrOverlay">

    <!-- ── GPS / COMPASS PANEL (top-left) ── -->
    <div id="gpsPanel">
      <div id="gpsBadge">
        <div id="gpsAccDot"></div>
        <div id="gpsText">
          <strong id="gpsCoordsText">Acquiring GPS…</strong>
          <span id="gpsAccText">accuracy: —</span>
        </div>
      </div>
      <div id="compassBadge">
        <div id="compassRose">
          <svg width="28" height="28" viewBox="0 0 28 28" id="compassSvg">
            <circle cx="14" cy="14" r="13" stroke="rgba(255,255,255,.12)" stroke-width="1" fill="none"/>
            <!-- N pointer red, S pointer white -->
            <polygon points="14,3 11,14 14,12 17,14" fill="#e84f2b"/>
            <polygon points="14,25 11,14 14,16 17,14" fill="rgba(255,255,255,.4)"/>
            <circle cx="14" cy="14" r="2" fill="rgba(255,255,255,.6)"/>
          </svg>
        </div>
        <div id="compassText">
          <strong id="compassHeadingText">—°</strong>
          <span id="compassDirText">compass</span>
        </div>
      </div>
      <div id="gpsDriftBadge"></div>
    </div>

    <!-- GPS minimap -->
    <div id="gpsMap">
      <canvas id="gpsMapCanvas" width="140" height="140"></canvas>
      <div id="gpsMapLabel">GPS Waypoints</div>
    </div>

    <!-- Waypoint label container -->
    <div id="wpLabels" style="position:absolute;inset:0;pointer-events:none;"></div>

    <!-- Scan / snap reticles -->
    <div id="scanRing">
      <svg width="180" height="180" viewBox="0 0 180 180" fill="none">
        <ellipse cx="90" cy="90" rx="78" ry="34" stroke="#e84f2b" stroke-width="1.5" stroke-dasharray="6 4"/>
        <ellipse cx="90" cy="90" rx="50" ry="22" stroke="rgba(232,79,43,.3)" stroke-width="1"/>
        <line x1="68" y1="90" x2="112" y2="90" stroke="#e84f2b" stroke-width="1.2"/>
        <line x1="90" y1="68" x2="90" y2="112" stroke="#e84f2b" stroke-width="1.2"/>
      </svg>
    </div>
    <div id="snapReticle">
      <svg width="64" height="64" viewBox="0 0 64 64" fill="none">
        <circle cx="32" cy="32" r="26" stroke="#4da6ff" stroke-width="1.5" stroke-dasharray="5 3" id="snapCircle"/>
        <line x1="32" y1="14" x2="32" y2="50" stroke="#4da6ff" stroke-width="1" id="snapV"/>
        <line x1="14" y1="32" x2="50" y2="32" stroke="#4da6ff" stroke-width="1" id="snapH"/>
        <circle cx="32" cy="32" r="4" fill="#4da6ff" id="snapDot"/>
      </svg>
    </div>

    <!-- Status badges -->
    <div id="snapIndicator">&#x25C6; Snapped to edge</div>
    <div id="cornerBadge"></div>
    <div id="planeBadge">&#x2713; Surface Detected</div>
    <div id="driftBadge">&#x21BA; Anchors updated</div>
    <div id="toast"></div>
    <div id="measureLabel"></div>

    <!-- ── PDF PICK OVERLAY (inside xrOverlay so it shows in WebXR) ── -->
    <div id="pickOverlay">
      <p id="pickTitle">PICK CORNERS ON THE PLAN</p>
      <p id="pickSub">Tap each column on the plan in the same order you anchored them</p>
      <div style="position:relative;display:inline-block;" id="pickWrapper">
        <canvas id="pickCanvas"></canvas>
      </div>
      <!-- Scale ruler panel -->
      <div id="rulerPanel">
        <span id="rulerUnit">&#x1F4CF; Drag a line on the plan, enter real length:</span>
      </div>
      <div id="rulerPanel2" style="display:none;align-items:center;gap:8px;flex-wrap:wrap;justify-content:center;margin-top:4px;">
        <input type="number" id="rulerDistInput" placeholder="e.g. 4.5" min="0.01" step="0.01">
        <span id="rulerUnit2" style="font-size:10px;letter-spacing:.18em;color:rgba(240,208,96,.7);">metres</span>
        <button id="rulerConfirmBtn" disabled>Set Scale</button>
        <span id="rulerStatus"></span>
      </div>
      <p id="pickInfo">0 corners picked</p>
      <div class="pick-btns">
        <button class="pick-btn" id="rulerModeBtn">&#x1F4CF; Set Scale</button>
        <button class="pick-btn" id="pickUndoBtn">&#x21B6; Undo</button>
        <button class="pick-btn" id="pickCancelBtn">Cancel</button>
        <button class="pick-btn confirm" id="pickConfirmBtn" disabled>Bind Plan &rarr;</button>
      </div>
    </div>

    <!-- ── HUD (inside xrOverlay) ── -->
    <div id="hud">
      <div id="hudHint">Point camera at the ground</div>
      <div id="statusBar"></div>
      <div class="slider-row">
        <span class="sl-lbl">Opacity</span>
        <input type="range" id="opacitySlider" min="20" max="100" value="82">
        <span class="sl-lbl" id="opacityVal">82%</span>
      </div>
      <div class="btn-row" id="normalBtns">
        <button class="hud-btn" id="alignBtn">&#x1F9ED; Align N</button>
        <button class="hud-btn" id="lockBtn">&#x1F513; Unlock</button>
        <button class="hud-btn b" id="traceBtn">&#x25CE; Anchor</button>
        <button class="hud-btn y" id="measureBtn">&#x1F4CF; Measure</button>
        <button class="hud-btn b" id="dropPinBtn" style="display:none;">&#x1F4CD; Pin</button>
        <button class="hud-btn" id="gpsToggleBtn">&#x1F6F0; GPS</button>
        <button class="hud-btn" id="resetBtn">Reset</button>
        <button class="hud-btn r" id="exitBtn">&#x2715; Exit</button>
      </div>
      <div class="btn-row" id="measureBtns" style="display:none;">
        <button class="hud-btn" id="measureClearBtn">&#x21B6; Clear</button>
        <button class="hud-btn r" id="measureExitBtn">&#x2715; Done</button>
      </div>
      <div class="btn-row" id="traceBtns" style="display:none;">
        <button class="hud-btn" id="traceUndoBtn">&#x21B6; Undo</button>
        <button class="hud-btn g" id="traceDoneBtn">&#x2713; Done</button>
        <button class="hud-btn r" id="traceCancelBtn">&#x2715; Cancel</button>
      </div>
    </div>

  </div><!-- end #xrOverlay -->
</div><!-- end #arScreen -->

<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
(function () {
'use strict';

pdfjsLib.GlobalWorkerOptions.workerSrc =
  'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

/* ═══════════════════════════════
   BOWYER-WATSON DELAUNAY (XZ)
═══════════════════════════════ */
function delaunay(pts) {
  if (pts.length < 3) return [];
  var minX=Infinity, minZ=Infinity, maxX=-Infinity, maxZ=-Infinity;
  pts.forEach(function(p){ minX=Math.min(minX,p.x); minZ=Math.min(minZ,p.z); maxX=Math.max(maxX,p.x); maxZ=Math.max(maxZ,p.z); });
  var span = Math.max(maxX-minX, maxZ-minZ)*10+1;
  var cx=(minX+maxX)/2, cz=(minZ+maxZ)/2;
  var all=pts.slice(), s0=all.length;
  all.push({x:cx-span*2,z:cz-span},{x:cx,z:cz+span*2},{x:cx+span*2,z:cz-span});
  var tris=[{a:s0,b:s0+1,c:s0+2}];

  function circ(t){
    var ax=all[t.a].x,az=all[t.a].z,bx=all[t.b].x,bz=all[t.b].z,cx2=all[t.c].x,cz2=all[t.c].z;
    var D=2*(ax*(bz-cz2)+bx*(cz2-az)+cx2*(az-bz));
    if(Math.abs(D)<1e-10) return {x:0,z:0,r2:1e18};
    var ux=((ax*ax+az*az)*(bz-cz2)+(bx*bx+bz*bz)*(cz2-az)+(cx2*cx2+cz2*cz2)*(az-bz))/D;
    var uz=((ax*ax+az*az)*(cx2-bx)+(bx*bx+bz*bz)*(ax-cx2)+(cx2*cx2+cz2*cz2)*(bx-ax))/D;
    var dx=ax-ux,dz=az-uz; return {x:ux,z:uz,r2:dx*dx+dz*dz};
  }

  for(var i=0;i<pts.length;i++){
    var p=all[i], bad=[], j;
    for(j=tris.length-1;j>=0;j--){var c2=circ(tris[j]),dx=p.x-c2.x,dz=p.z-c2.z; if(dx*dx+dz*dz<c2.r2){bad.push(tris[j]);tris.splice(j,1);}}
    var edges=[];
    bad.forEach(function(t){[[t.a,t.b],[t.b,t.c],[t.c,t.a]].forEach(function(e){
      if(!bad.some(function(t2){return t2!==t&&(t2.a===e[0]||t2.b===e[0]||t2.c===e[0])&&(t2.a===e[1]||t2.b===e[1]||t2.c===e[1]);}))edges.push(e);
    });});
    edges.forEach(function(e){tris.push({a:e[0],b:e[1],c:i});});
  }
  return tris.filter(function(t){return t.a<s0&&t.b<s0&&t.c<s0;});
}

/* ═══════════════════════════════
   STATE
═══════════════════════════════ */
var pdfDoc=null, currentPage=1, pdfCanvas=null;
var xfOpacity=0.82, xfRotY=0.0, xfScaleM=1.0, xfLocked=true;
var traceMode=false, MAX_CORNERS=10;
var corners=[];   // {worldPos:{x,y,z}, anchor:XRAnchor|null}
var uvPicks=[];   // {u,v}  — plan UV coords for each column
var boundMesh=null, solveCount=0;
var currentSnap=null;

/* ── Rigid plan transform (Kabsch solver output) ──
   The plan is a single rigid body.  We never warp it.
   planOrigin: THREE.Vector3  — world position of plan centre
   planYaw:    number (rad)   — plan rotation around world-up
   planScale:  number (m/UV)  — uniform scale
   These are the ONLY things that change when we re-solve.         */
var planOrigin=new THREE.Vector3();
var planYaw=0;
var planScale=1;
var planBound=false;  // true once first Kabsch solve succeeds

/* ── Heading fusion state ──
   We run a complementary filter:
     fusedHeading = α·compassRaw + (1-α)·(fusedHeading + gyroRate·dt)
   α=0.02 → gyro dominates short-term, compass corrects long-term drift */
var fusedHeading=null;    // degrees, 0=North
var lastGyroTime=null;
var gyroRate=0;           // deg/s from deviceorientation alpha delta
var lastAlpha=null;       // previous deviceorientation alpha
var COMPASS_ALPHA=0.02;   // complementary filter weight for compass
var headingLocked=false;  // true once we have a stable fused heading

/* GPS bearing calibration — two fixes = one bearing vector */
var gpsBearingFixes=[];   // [{lat,lng,ts}] — rolling buffer, last 6
var gpsBearingRef=null;   // {heading:deg, confidence:0-1} from GPS pairs

/* Plane re-snap throttle */
var reSnapFrameCounter=0;
var RESNAP_INTERVAL=45;   // frames between re-snap attempts
var RESNAP_THRESHOLD=0.15; // metres — max allowed silent correction

/* Per-constraint quality — fed to status panel */
var constraintQuality={
  xrAnchor:  0,   // 0-1
  compass:   0,
  gpsBearing:0,
  planeSnap: 0
};

/* Scale ruler */
var metersPerUV=null;    // set by ruler: metres / UV unit distance
var rulerMode=false;     // true while user is dragging ruler line on pickCanvas
var rulerP1=null, rulerP2=null;   // {x,y} in pickCanvas coords (normalised 0-1)
var rulerLine=null;      // SVG overlay line element

/* Measurement tool */
var measureMode=false;
var measurePt1=null, measurePt2=null;   // THREE.Vector3 world positions
var measureLine=null;    // THREE.Line in scene
var measureDots=[];      // sphere meshes

/* Three.js / XR */
var xrSession=null, xrRefSpace=null, xrHitTestSrc=null;
var renderer=null, scene=null, camera=null, reticle=null;
var planeGroup=null, planeMesh=null;
var wxrPlaced=false, wxrFloorFound=false;
var surfaceQuat=new THREE.Quaternion();
var floorPlane=new THREE.Plane(new THREE.Vector3(0,1,0),0);
var prevPinchDist=null, prevPinchAngle=null;

/* Wire visuals */
var wireLines=[], wireDots=[];
var planeWires=new Map();   // XRPlane -> THREE.Line (boundary loop)
var planesEnabled=false;    // true once we confirm frame.detectedPlanes works

var CORNER_COLORS=[0xe84f2b,0x2be87a,0x4da6ff,0xf0d060,0xe030f0,0x30e0f0,0xf09030,0xff88aa,0x88ffcc,0xccaaff];

/* ═══════════════════════════════
   DOM HELPERS
═══════════════════════════════ */
function el(id){ return document.getElementById(id); }
function show(id,d){ el(id).style.display=d||'block'; }
function hide(id){ el(id).style.display='none'; }
function showBtns(which){
  el('normalBtns').style.display  = which==='normal'?'flex':'none';
  el('traceBtns').style.display   = which==='trace'?'flex':'none';
  el('measureBtns').style.display = which==='measure'?'flex':'none';
}
function showToast(msg,dur){
  el('toast').textContent=msg; show('toast');
  clearTimeout(showToast._t);
  showToast._t=setTimeout(function(){hide('toast');},dur||2600);
}

/* ═══════════════════════════════
   PDF LOAD
═══════════════════════════════ */
el('dropZone').addEventListener('click',function(){el('fileInput').click();});
el('dropZone').addEventListener('dragover',function(e){e.preventDefault();el('dropZone').classList.add('over');});
el('dropZone').addEventListener('dragleave',function(){el('dropZone').classList.remove('over');});
el('dropZone').addEventListener('drop',function(e){e.preventDefault();el('dropZone').classList.remove('over');if(e.dataTransfer.files[0])loadFile(e.dataTransfer.files[0]);});
el('fileInput').addEventListener('change',function(){if(el('fileInput').files[0])loadFile(el('fileInput').files[0]);});

function loadFile(f){
  hide('errMsg'); el('launchBtn').classList.remove('show');
  var reader=new FileReader();
  reader.onload=function(ev){
    pdfjsLib.getDocument({data:ev.target.result}).promise
      .then(function(doc){pdfDoc=doc;currentPage=1;renderPage(1);el('pageNav').style.display=doc.numPages>1?'flex':'none';})
      .catch(function(e){showErr('PDF error: '+e.message);});
  };
  reader.onerror=function(){showErr('Read error.');};
  reader.readAsArrayBuffer(f);
}
function showErr(m){el('errMsg').textContent=m;show('errMsg');}
function renderPage(n){
  el('launchBtn').classList.remove('show');
  pdfDoc.getPage(n).then(function(page){
    var vp0=page.getViewport({scale:1});
    var sc=Math.min(8,8192/Math.max(vp0.width,vp0.height));
    var vp=page.getViewport({scale:sc});
    var hi=document.createElement('canvas');
    hi.width=Math.round(vp.width); hi.height=Math.round(vp.height);
    var thumb=el('pdfThumb'); thumb.width=Math.round(vp.width/4); thumb.height=Math.round(vp.height/4);
    thumb.style.display='block';
    var tCtx=thumb.getContext('2d'); tCtx.fillStyle='#12121f'; tCtx.fillRect(0,0,thumb.width,thumb.height);
    tCtx.fillStyle='#e84f2b'; tCtx.font='12px Courier New'; tCtx.textAlign='center';
    tCtx.fillText('Rendering '+hi.width+'\u00d7'+hi.height+'\u2026',thumb.width/2,thumb.height/2); tCtx.textAlign='left';
    page.render({canvasContext:hi.getContext('2d'),viewport:vp}).promise.then(function(){
      pdfCanvas=hi; tCtx.clearRect(0,0,thumb.width,thumb.height); tCtx.drawImage(hi,0,0,thumb.width,thumb.height);
      el('pgInfo').textContent=n+' / '+pdfDoc.numPages; el('launchBtn').classList.add('show');
    }).catch(function(e){showErr('Render error: '+e.message);});
  });
}
el('prevPg').addEventListener('click',function(){if(currentPage>1)renderPage(--currentPage);});
el('nextPg').addEventListener('click',function(){if(pdfDoc&&currentPage<pdfDoc.numPages)renderPage(++currentPage);});

/* ═══════════════════════════════
   LAUNCH
═══════════════════════════════ */
el('launchBtn').addEventListener('click',function(){
  if(!pdfCanvas)return;
  hide('landing'); show('arScreen');
  if(navigator.xr){
    navigator.xr.isSessionSupported('immersive-ar')
      .then(function(ok){ok?startWebXR():noXR();}).catch(noXR);
  }else{noXR();}
});
function noXR(){el('hudHint').textContent='WebXR not supported \u2014 requires Android Chrome or compatible AR browser';}

/* ═══════════════════════════════
   HUD CONTROLS
═══════════════════════════════ */
el('opacitySlider').addEventListener('input',function(){
  xfOpacity=parseFloat(this.value)/100; el('opacityVal').textContent=this.value+'%';
  if(planeMesh)planeMesh.material.opacity=xfOpacity;
  if(boundMesh)boundMesh.material.opacity=xfOpacity;
});
el('rotCW') && el('rotCW').addEventListener && void 0; // removed
el('alignBtn').addEventListener('click',function(){
  if(!wxrPlaced){showToast('Place the plan first');return;}
  var h=fusedHeading!=null?fusedHeading:compassHeading;
  if(h==null){showToast('No compass heading \u2014 enable GPS first');return;}
  xfRotY=h*Math.PI/180; planYaw=xfRotY;
  applyFree();
  if(planRigidGroup)planRigidGroup.rotation.y=planYaw;
  showToast('Plan aligned to '+Math.round(h)+'\u00b0 (fused) \u2714');
});
el('lockBtn').addEventListener('click',function(){
  xfLocked=!xfLocked;
  this.textContent=xfLocked?'\uD83D\uDD12 Locked':'\uD83D\uDD13 Unlock';
  this.className=xfLocked?'hud-btn g':'hud-btn';
  showToast(xfLocked?'Locked':'Drag to reposition');
});
function applyFree(){if(planeGroup&&wxrPlaced)planeGroup.rotation.y=xfRotY;}

el('traceBtn').addEventListener('click',function(){
  if(!wxrFloorFound&&!wxrPlaced){showToast('Point at the ground first');return;}
  enterTraceMode();
});
el('traceUndoBtn').addEventListener('click',undoCorner);
el('traceDoneBtn').addEventListener('click',function(){
  if(corners.length<3){showToast('Need at least 3 column anchors');return;}
  showBtns('normal');
  hide('snapReticle'); hide('snapIndicator'); hide('cornerBadge');
  traceMode=false;
  openPickOverlay();
});
el('traceCancelBtn').addEventListener('click',cancelTrace);
el('resetBtn').addEventListener('click',doReset);
el('exitBtn').addEventListener('click',function(){
  if(xrSession){try{xrSession.end();}catch(e){}xrSession=null;}
  if(gpsEnabled)stopGPS();
  hide('arScreen'); show('landing','flex'); doReset();
});

/* ═══════════════════════════════
   ANCHOR MODE (column anchoring)
═══════════════════════════════ */
function enterTraceMode(){
  traceMode=true; corners=[];
  showBtns('trace'); hide('scanRing'); show('snapReticle'); show('cornerBadge');
  el('traceDoneBtn').style.opacity='0.4';
  updateCornerBadge();
  el('hudHint').textContent='Walk to each column base and tap to anchor';
  showToast('Stand at each column \u2014 snaps to detected structure edges');
}
function cancelTrace(){
  traceMode=false; corners=[]; clearWireVisuals();
  showBtns('normal'); hide('snapReticle'); hide('snapIndicator'); hide('cornerBadge');
  el('hudHint').textContent=wxrPlaced?'Plan placed \u2022 Tap Anchor to bind to columns':'Point camera at the ground';
}
function undoCorner(){
  if(corners.length===0)return;
  var c=corners.pop();
  if(c.anchor){try{c.anchor.delete();}catch(e){}}
  if(wireDots.length>0)scene.remove(wireDots.pop());
  if(wireLines.length>0)scene.remove(wireLines.pop());
  updateCornerBadge();
}
function updateCornerBadge(){
  var n=corners.length;
  el('cornerBadge').textContent=n+' column'+(n!==1?'s':'')+' anchored'+
    (n<3?' \u2014 need '+(3-n)+' more':' \u2014 tap Done when ready');
  el('traceDoneBtn').style.opacity=n>=3?'1':'0.4';
}
function addCornerVisual(pos,idx){
  var col=CORNER_COLORS[idx%CORNER_COLORS.length];
  var dot=new THREE.Mesh(new THREE.SphereGeometry(0.055,10,10),new THREE.MeshBasicMaterial({color:col}));
  dot.position.set(pos.x,pos.y+0.055,pos.z); scene.add(dot); wireDots.push(dot);
  if(corners.length>1){
    var prev=corners[corners.length-2].worldPos;
    var geo=new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(prev.x,prev.y+0.012,prev.z),
      new THREE.Vector3(pos.x,pos.y+0.012,pos.z)
    ]);
    var line=new THREE.Line(geo,new THREE.LineBasicMaterial({color:col}));
    scene.add(line); wireLines.push(line);
  }
}
function clearWireVisuals(){
  if(!scene)return;
  wireLines.forEach(function(l){scene.remove(l);}); wireLines=[];
  wireDots.forEach(function(d){scene.remove(d);}); wireDots=[];
}
function doReset(){
  traceMode=false; corners=[]; uvPicks=[];
  wxrPlaced=false; xfLocked=true; xfRotY=0; xfScaleM=1;
  currentSnap=null; solveCount=0;
  measureMode=false; measurePt1=null; measurePt2=null;
  metersPerUV=null; rulerP1=null; rulerP2=null;
  planBound=false; planYaw=0; planScale=1; planOrigin.set(0,0,0);
  fusedHeading=null; headingLocked=false; lastAlpha=null; lastGyroTime=null;
  gpsBearingFixes=[]; gpsBearingRef=null; reSnapFrameCounter=0;
  constraintQuality={xrAnchor:0,compass:0,gpsBearing:0,planeSnap:0};
  clearMeasureVisuals(); hide('measureLabel');
  clearWaypoints();
  if(planRigidGroup&&scene){scene.remove(planRigidGroup);planRigidGroup=null;boundMesh=null;}
  else if(boundMesh&&scene){scene.remove(boundMesh);boundMesh=null;}
  if(planeGroup)planeGroup.visible=false;
  clearWireVisuals(); clearPlaneWires();
  showBtns('normal');
  show('scanRing'); hide('snapReticle'); hide('cornerBadge');
  hide('snapIndicator'); hide('driftBadge'); hide('planeBadge');
  hide('statusBar'); hide('pickOverlay');
  el('hudHint').textContent='Point camera at the ground';
  el('lockBtn').textContent='\uD83D\uDD13 Unlock'; el('lockBtn').className='hud-btn';
}

/* ═══════════════════════════════
   DETECTED PLANE WIREFRAMES
   Draws a green loop on floor planes,
   blue loop on wall planes.
   Works when plane-detection is enabled
   (Chrome flag or supported device).
   Falls back gracefully when unavailable.
═══════════════════════════════ */
function updatePlaneWireframes(frame, refSpace){
  if(!frame.detectedPlanes) return;
  planesEnabled=true;
  var seen=new Set();

  frame.detectedPlanes.forEach(function(plane){
    if(!plane.planeSpace||!plane.polygon||plane.polygon.length<3) return;
    try{
      var pp=frame.getPose(plane.planeSpace,refSpace);
      if(!pp) return;
      var pm=new THREE.Matrix4().fromArray(pp.transform.matrix);
      var isWall=plane.orientation==='vertical';
      var col=isWall?0x4da6ff:0x2be87a;
      var yOff=isWall?0:0.008;  // lift floor loops slightly off surface

      /* Build world-space points for boundary loop */
      var wpts=plane.polygon.map(function(v){
        return new THREE.Vector3(v.x,v.y,v.z).applyMatrix4(pm);
      });
      /* Close the loop */
      wpts.push(wpts[0].clone());
      var lifted=wpts.map(function(p){return new THREE.Vector3(p.x,p.y+yOff,p.z);});

      var existing=planeWires.get(plane);
      if(existing){
        /* Update positions in-place */
        var arr=new Float32Array(lifted.length*3);
        lifted.forEach(function(p,i){arr[i*3]=p.x;arr[i*3+1]=p.y;arr[i*3+2]=p.z;});
        existing.geometry.setAttribute('position',new THREE.BufferAttribute(arr,3));
        existing.geometry.attributes.position.needsUpdate=true;
        existing.geometry.computeBoundingSphere();
      } else {
        var geo=new THREE.BufferGeometry().setFromPoints(lifted);
        var mat=new THREE.LineBasicMaterial({color:col,transparent:true,opacity:isWall?0.75:0.55});
        var loop=new THREE.Line(geo,mat);
        scene.add(loop);
        planeWires.set(plane,loop);

        /* For floor planes also draw a grid inside the boundary so the
           surface area is visible when looking straight down           */
        if(!isWall){
          drawFloorGrid(pm, plane.polygon, col);
        }
      }
      seen.add(plane);
    }catch(e){}
  });

  /* Remove stale plane wires */
  planeWires.forEach(function(wire,key){
    if(typeof key!=='string' && !seen.has(key)){
      scene.remove(wire); planeWires.delete(key);
    }
  });
}

function drawFloorGrid(pm, polygon, col){
  var xs=polygon.map(function(v){return v.x;});
  var zs=polygon.map(function(v){return v.z;});
  var minX=Math.min.apply(null,xs),maxX=Math.max.apply(null,xs);
  var minZ=Math.min.apply(null,zs),maxZ=Math.max.apply(null,zs);
  var stepX=Math.max(0.25,(maxX-minX)/6);
  var stepZ=Math.max(0.25,(maxZ-minZ)/6);
  var pts=[];
  for(var x=minX;x<=maxX+0.01;x+=stepX){
    var p1=new THREE.Vector3(x,0.007,minZ).applyMatrix4(pm);
    var p2=new THREE.Vector3(x,0.007,maxZ).applyMatrix4(pm);
    pts.push(p1,p2);
  }
  for(var z=minZ;z<=maxZ+0.01;z+=stepZ){
    var p3=new THREE.Vector3(minX,0.007,z).applyMatrix4(pm);
    var p4=new THREE.Vector3(maxX,0.007,z).applyMatrix4(pm);
    pts.push(p3,p4);
  }
  if(pts.length<2)return;
  var geo=new THREE.BufferGeometry().setFromPoints(pts);
  var mat=new THREE.LineBasicMaterial({color:col,transparent:true,opacity:0.18});
  var segs=new THREE.LineSegments(geo,mat);
  scene.add(segs);
  /* Store with string key so it doesn't get reaped by the plane cleanup loop */
  planeWires.set('grid_'+Math.random().toString(36).slice(2),segs);
}

function clearPlaneWires(){
  if(!scene)return;
  planeWires.forEach(function(w){scene.remove(w);});
  planeWires.clear(); planesEnabled=false;
}

/* ═══════════════════════════════
   SNAP TO NEAREST PLANE VERTEX
═══════════════════════════════ */
var SNAP_DIST=0.35;
function snapToNearestPlaneVertex(pos,frame,refSpace){
  if(!frame.detectedPlanes) return null;
  var best=null, bestD2=SNAP_DIST*SNAP_DIST;
  frame.detectedPlanes.forEach(function(plane){
    if(!plane.planeSpace) return;
    try{
      var pp=frame.getPose(plane.planeSpace,refSpace);
      if(!pp) return;
      var pm=new THREE.Matrix4().fromArray(pp.transform.matrix);
      plane.polygon.forEach(function(v){
        var wp=new THREE.Vector3(v.x,v.y,v.z).applyMatrix4(pm);
        var dx=wp.x-pos.x, dz=wp.z-pos.z, d2=dx*dx+dz*dz;
        if(d2<bestD2){bestD2=d2;best=wp.clone();}
      });
    }catch(e){}
  });
  return best;
}

/* ═══════════════════════════════
   SCALE RULER (in pick overlay)
═══════════════════════════════ */
function initRulerOnCanvas(pc){
  // Remove old SVG ruler overlay if any
  var old=el('pickWrapper').querySelector('#rulerSvg');
  if(old)old.parentNode.removeChild(old);
  rulerP1=null; rulerP2=null; rulerMode=false;

  // Create SVG overlay
  var svg=document.createElementNS('http://www.w3.org/2000/svg','svg');
  svg.id='rulerSvg';
  svg.setAttribute('width',pc.width); svg.setAttribute('height',pc.height);
  svg.style.cssText='position:absolute;left:'+pc.offsetLeft+'px;top:'+pc.offsetTop+'px;pointer-events:all;z-index:5;';
  var line=document.createElementNS('http://www.w3.org/2000/svg','line');
  line.setAttribute('stroke','#f0d060'); line.setAttribute('stroke-width','2.5');
  line.setAttribute('stroke-dasharray','6 4'); line.setAttribute('display','none');
  var c1=document.createElementNS('http://www.w3.org/2000/svg','circle');
  c1.setAttribute('r','5'); c1.setAttribute('fill','#f0d060'); c1.setAttribute('display','none');
  var c2=document.createElementNS('http://www.w3.org/2000/svg','circle');
  c2.setAttribute('r','5'); c2.setAttribute('fill','#f0d060'); c2.setAttribute('display','none');
  svg.appendChild(line); svg.appendChild(c1); svg.appendChild(c2);
  el('pickWrapper').appendChild(svg);
  rulerLine=line;

  function getXY(e){
    var r=pc.getBoundingClientRect();
    var clientX=e.touches?e.touches[0].clientX:e.clientX;
    var clientY=e.touches?e.touches[0].clientY:e.clientY;
    return{x:clientX-r.left,y:clientY-r.top};
  }

  svg.addEventListener('mousedown',function(e){if(!rulerMode)return; e.stopPropagation();
    var p=getXY(e); rulerP1={x:p.x/pc.width,y:p.y/pc.height};
    c1.setAttribute('cx',p.x); c1.setAttribute('cy',p.y); c1.setAttribute('display','');
    c2.setAttribute('display','none'); line.setAttribute('display','none');
    el('rulerStatus').textContent=''; el('rulerConfirmBtn').disabled=true;
  });
  svg.addEventListener('touchstart',function(e){if(!rulerMode)return; e.preventDefault(); e.stopPropagation();
    var p=getXY(e); rulerP1={x:p.x/pc.width,y:p.y/pc.height};
    c1.setAttribute('cx',p.x); c1.setAttribute('cy',p.y); c1.setAttribute('display','');
    c2.setAttribute('display','none'); line.setAttribute('display','none');
  },{passive:false});

  svg.addEventListener('mousemove',function(e){if(!rulerMode||!rulerP1)return; e.stopPropagation();
    var p=getXY(e);
    line.setAttribute('x1',rulerP1.x*pc.width); line.setAttribute('y1',rulerP1.y*pc.height);
    line.setAttribute('x2',p.x); line.setAttribute('y2',p.y); line.setAttribute('display','');
    c2.setAttribute('cx',p.x); c2.setAttribute('cy',p.y); c2.setAttribute('display','');
  });
  svg.addEventListener('touchmove',function(e){if(!rulerMode||!rulerP1)return; e.preventDefault(); e.stopPropagation();
    var p=getXY(e);
    line.setAttribute('x1',rulerP1.x*pc.width); line.setAttribute('y1',rulerP1.y*pc.height);
    line.setAttribute('x2',p.x); line.setAttribute('y2',p.y); line.setAttribute('display','');
    c2.setAttribute('cx',p.x); c2.setAttribute('cy',p.y); c2.setAttribute('display','');
  },{passive:false});

  function finishRuler(e){
    if(!rulerMode||!rulerP1)return;
    var p=getXY(e);
    rulerP2={x:p.x/pc.width,y:p.y/pc.height};
    c2.setAttribute('cx',p.x); c2.setAttribute('cy',p.y); c2.setAttribute('display','');
    var du=rulerP2.x-rulerP1.x, dv=rulerP2.y-rulerP1.y;
    var pxDist=Math.sqrt(du*du+dv*dv);
    el('rulerStatus').textContent='Line: '+Math.round(pxDist*pc.width)+' px on plan';
    el('rulerConfirmBtn').disabled=pxDist<0.01;
  }
  svg.addEventListener('mouseup',function(e){e.stopPropagation(); finishRuler(e);});
  svg.addEventListener('touchend',function(e){e.preventDefault(); e.stopPropagation(); finishRuler(e.changedTouches[0]?e.changedTouches[0]:e);},{passive:false});
}

el('rulerModeBtn').addEventListener('click',function(){
  rulerMode=!rulerMode;
  this.className='pick-btn'+(rulerMode?' ruler-active':'');
  this.textContent=rulerMode?'&#x1F4CF; Drawing\u2026':'&#x1F4CF; Set Scale';
  el('rulerPanel2').style.display=rulerMode?'flex':'none';
  var svg=el('pickWrapper').querySelector('#rulerSvg');
  if(svg)svg.style.pointerEvents=rulerMode?'all':'none';
  if(!rulerMode){rulerP1=null;rulerP2=null;}
  // Block pickCanvas clicks in ruler mode
  el('pickCanvas').style.pointerEvents=rulerMode?'none':'all';
});

el('rulerConfirmBtn').addEventListener('click',function(){
  if(!rulerP1||!rulerP2)return;
  var realMetres=parseFloat(el('rulerDistInput').value);
  if(!realMetres||realMetres<=0){el('rulerStatus').textContent='Enter a valid distance'; return;}
  var du=rulerP2.x-rulerP1.x, dv=rulerP2.y-rulerP1.y;
  var uvDist=Math.sqrt(du*du+dv*dv*((pdfCanvas.width/pdfCanvas.height)**2)); // account for aspect
  metersPerUV=realMetres/uvDist;
  el('rulerStatus').textContent='\u2714 Scale set: 1 unit = '+(metersPerUV).toFixed(3)+'m';
  showToast('Scale: '+realMetres+'m across that line \u2714');
  rulerMode=false; el('rulerModeBtn').className='pick-btn'; el('rulerModeBtn').textContent='&#x1F4CF; Set Scale';
  el('pickCanvas').style.pointerEvents='all';
  var svg=el('pickWrapper').querySelector('#rulerSvg');
  if(svg)svg.style.pointerEvents='none';
});

/* ═══════════════════════════════
   MEASUREMENT TOOL
═══════════════════════════════ */
function enterMeasureMode(){
  measureMode=true; measurePt1=null; measurePt2=null;
  clearMeasureVisuals();
  el('normalBtns').style.display='none';
  el('measureBtns').style.display='flex';
  hide('measureLabel');
  el('hudHint').textContent='Tap floor for point 1\u2026';
}
function exitMeasureMode(){
  measureMode=false; measurePt1=null; measurePt2=null;
  clearMeasureVisuals();
  el('normalBtns').style.display='flex';
  el('measureBtns').style.display='none';
  hide('measureLabel');
  el('hudHint').textContent=wxrPlaced?'Plan placed \u2022 Tap to measure':'Point camera at the ground';
}
function clearMeasureVisuals(){
  if(!scene)return;
  if(measureLine){scene.remove(measureLine);measureLine=null;}
  measureDots.forEach(function(d){scene.remove(d);}); measureDots=[];
}
function buildMeasureLine(a,b){
  clearMeasureVisuals();
  [a,b].forEach(function(p){
    var dot=new THREE.Mesh(new THREE.SphereGeometry(0.028,10,10),new THREE.MeshBasicMaterial({color:0xf0d060}));
    dot.position.set(p.x,p.y+0.028,p.z); scene.add(dot); measureDots.push(dot);
  });
  var geo=new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(a.x,a.y+0.015,a.z),
    new THREE.Vector3(b.x,b.y+0.015,b.z)
  ]);
  measureLine=new THREE.Line(geo,new THREE.LineBasicMaterial({color:0xf0d060,linewidth:2}));
  scene.add(measureLine);
}
function updateMeasureLabel(worldA, worldB){
  // Calculate raw 3D distance
  var dx=worldB.x-worldA.x, dy=worldB.y-worldA.y, dz=worldB.z-worldA.z;
  var dist3D=Math.sqrt(dx*dx+dy*dy+dz*dz);
  var label=el('measureLabel');
  if(metersPerUV){
    // We have a user-set scale — but note: if plan is bound, world coords ARE metric already.
    // metersPerUV was set in UV space. World metres are actual AR metres.
    label.textContent=dist3D.toFixed(2)+' m';
  } else {
    label.textContent=dist3D.toFixed(2)+' m (AR)';
  }
  // Project midpoint to screen
  var mid=new THREE.Vector3((worldA.x+worldB.x)/2,(worldA.y+worldB.y)/2+0.06,(worldA.z+worldB.z)/2);
  var proj=mid.clone().project(camera);
  var sx=(proj.x*0.5+0.5)*window.innerWidth;
  var sy=(-proj.y*0.5+0.5)*window.innerHeight;
  label.style.left=sx+'px'; label.style.top=sy+'px';
  show('measureLabel');
}

el('measureBtn').addEventListener('click',function(){
  if(!wxrPlaced&&!wxrFloorFound){showToast('Place the plan first');return;}
  enterMeasureMode();
});
el('measureClearBtn').addEventListener('click',function(){
  measurePt1=null; measurePt2=null; clearMeasureVisuals(); hide('measureLabel');
  el('hudHint').textContent='Tap floor for point 1\u2026';
});
el('measureExitBtn').addEventListener('click',exitMeasureMode);

/* ═══════════════════════════════════════════════════
   GPS · COMPASS · WAYPOINTS · DRIFT ANALYSIS
   ═══════════════════════════════════════════════════

   GPS state
   ─────────────────────────────────────────────────── */
var gpsEnabled=false;
var gpsWatchId=null;
var gpsLat=null, gpsLng=null, gpsAcc=null, gpsAlt=null;
var gpsFix=null;          // latest GeolocationPosition

/* Compass state */
var compassHeading=null;          // degrees true (0=N, 90=E)
var compassListening=false;

/* Waypoints — each: { id, gps:{lat,lng,acc}, world:{x,y,z}, label, dot:THREE.Mesh, labelEl } */
var waypoints=[];
var WP_COLORS=[0x4da6ff,0xe030f0,0x30e0f0,0xf09030,0xff88aa];

/* ── Geolocation helpers ── */
function haversineM(lat1,lng1,lat2,lng2){
  var R=6371000, dLat=(lat2-lat1)*Math.PI/180, dLng=(lng2-lng1)*Math.PI/180;
  var a=Math.sin(dLat/2)*Math.sin(dLat/2)+
        Math.cos(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180)*
        Math.sin(dLng/2)*Math.sin(dLng/2);
  return R*2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));
}
function bearingDeg(lat1,lng1,lat2,lng2){
  var dLng=(lng2-lng1)*Math.PI/180;
  var y=Math.sin(dLng)*Math.cos(lat2*Math.PI/180);
  var x=Math.cos(lat1*Math.PI/180)*Math.sin(lat2*Math.PI/180)-
        Math.sin(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180)*Math.cos(dLng);
  return (Math.atan2(y,x)*180/Math.PI+360)%360;
}
function fmtCoord(v,pos,neg){ return Math.abs(v).toFixed(6)+'\u00b0 '+(v>=0?pos:neg); }
function fmtAcc(a){ return a<5?'±'+a.toFixed(1)+'m':a<20?'±'+Math.round(a)+'m':'±'+Math.round(a)+'m ⚠'; }

function accClass(a){ return a==null?'red':a<10?'green':a<30?'yellow':'red'; }

/* ── Start/stop GPS ── */
function startGPS(){
  if(!navigator.geolocation){ showToast('Geolocation not supported'); return; }
  gpsEnabled=true;
  el('gpsPanel').classList.add('show');
  el('dropPinBtn').style.display='';
  el('gpsToggleBtn').className='hud-btn g';
  el('gpsToggleBtn').textContent='\uD83D\uDEF0 GPS On';
  gpsWatchId=navigator.geolocation.watchPosition(
    onGpsFix, onGpsErr,
    {enableHighAccuracy:true, maximumAge:2000, timeout:10000}
  );
  startCompass();
  show('gpsMap'); renderMiniMap();
}
function stopGPS(){
  gpsEnabled=false;
  if(gpsWatchId!=null){ navigator.geolocation.clearWatch(gpsWatchId); gpsWatchId=null; }
  el('gpsPanel').classList.remove('show');
  el('dropPinBtn').style.display='none';
  el('gpsToggleBtn').className='hud-btn';
  el('gpsToggleBtn').textContent='\uD83D\uDEF0 GPS';
  hide('gpsMap');
  stopCompass();
}

function onGpsFix(pos){
  gpsFix=pos;
  gpsLat=pos.coords.latitude; gpsLng=pos.coords.longitude;
  gpsAcc=pos.coords.accuracy; gpsAlt=pos.coords.altitude;
  updateGPSBadge();
  ingestGPSForBearing(gpsLat,gpsLng,gpsAcc);
  /* Run GPS drift analysis against column waypoints */
  var paired=waypoints.filter(function(w){return w.gps&&w.world;});
  if(paired.length>=2) runDriftAnalysis(paired);
}
function onGpsErr(e){ el('gpsCoordsText').textContent='GPS error: '+e.message; }

function updateGPSBadge(){
  if(gpsLat==null)return;
  el('gpsCoordsText').textContent=fmtCoord(gpsLat,'N','S')+'  '+fmtCoord(gpsLng,'E','W');
  el('gpsAccText').textContent='acc: '+fmtAcc(gpsAcc)+(gpsAlt!=null?' · alt: '+Math.round(gpsAlt)+'m':'');
  var dot=el('gpsAccDot');
  dot.className=''; dot.classList.add(accClass(gpsAcc));
  renderMiniMap();
}

/* ── Compass (DeviceOrientationEvent) ── */
function startCompass(){
  if(compassListening)return;
  function handler(e){
    var ts=performance.now();
    /* Absolute heading */
    var h=null;
    if(e.webkitCompassHeading!=null){ h=e.webkitCompassHeading; }
    else if(e.absolute&&e.alpha!=null){ h=(360-e.alpha)%360; }
    else if(e.alpha!=null){ h=(360-e.alpha)%360; }
    if(h==null)return;
    compassHeading=h;
    updateCompassBadge(h);
    /* Feed complementary filter — passes raw alpha for gyro delta */
    var alphaRaw=e.alpha||0;
    updateFusedHeading(h, alphaRaw, ts);
  }
  if(typeof DeviceOrientationEvent!=='undefined'&&
     typeof DeviceOrientationEvent.requestPermission==='function'){
    DeviceOrientationEvent.requestPermission().then(function(s){
      if(s==='granted'){ window.addEventListener('deviceorientation',handler,true); compassListening=true; }
    }).catch(function(){});
  } else {
    window.addEventListener('deviceorientation',handler,true);
    compassListening=true;
  }
}
function stopCompass(){
  /* We can't easily remove anonymous listener but gpsEnabled gate stops updates */
  compassListening=false;
}
function updateCompassBadge(h){
  if(!gpsEnabled)return;
  el('compassHeadingText').textContent=Math.round(h)+'\u00b0';
  var dirs=['N','NE','E','SE','S','SW','W','NW','N'];
  el('compassDirText').textContent=dirs[Math.round(h/45)%8];
  /* Rotate compass rose — needle points to N, so rotate svg by -heading to keep N up */
  el('compassSvg').style.transform='rotate('+(-h)+'deg)';
}

/* ── GPS Toggle button ── */
el('gpsToggleBtn').addEventListener('click',function(){
  if(gpsEnabled) stopGPS(); else startGPS();
});

/* ── Drop Pin ── */
el('dropPinBtn').addEventListener('click',function(){
  if(!reticle||!reticle.visible){ showToast('Point at the ground first'); return; }
  if(gpsLat==null){ showToast('No GPS fix yet'); return; }
  if(gpsAcc>25){ showToast('GPS accuracy poor ('+Math.round(gpsAcc)+'m) — move to open sky'); return; }

  var rx=reticle.matrix.elements[12],ry=reticle.matrix.elements[13],rz=reticle.matrix.elements[14];
  var fp=currentSnap?{x:currentSnap.x,y:currentSnap.y,z:currentSnap.z}:{x:rx,y:ry,z:rz};
  var idx=waypoints.length;
  var col=WP_COLORS[idx%WP_COLORS.length];

  /* 3D dot */
  var dot=new THREE.Mesh(
    new THREE.SphereGeometry(0.045,12,12),
    new THREE.MeshBasicMaterial({color:col})
  );
  dot.position.set(fp.x,fp.y+0.045,fp.z);
  scene.add(dot);

  /* DOM label */
  var lbl=document.createElement('div');
  lbl.className='wp-label';
  lbl.textContent='WP'+(idx+1)+' ±'+Math.round(gpsAcc)+'m';
  lbl.style.background='#'+col.toString(16).padStart(6,'0');
  lbl.style.color=col>0x888888?'#04050f':'#ffffff';
  el('wpLabels').appendChild(lbl);

  var wp={
    id:idx+1,
    gps:{lat:gpsLat,lng:gpsLng,acc:gpsAcc},
    world:{x:fp.x,y:fp.y,z:fp.z},
    dot:dot, labelEl:lbl
  };
  waypoints.push(wp);

  showToast('WP'+(idx+1)+' pinned \u2014 GPS ±'+Math.round(gpsAcc)+'m');
  renderMiniMap();

  /* Immediately run analysis if we have enough */
  var paired=waypoints.filter(function(w){return w.gps&&w.world;});
  if(paired.length>=2) runDriftAnalysis(paired);
});

/* ── Drift Analysis ──────────────────────────────────────────────
   For each pair of waypoints we compare:
     GPS distance between them  (haversine metres)
     XR world distance between them  (3D euclidean, XZ only for floor)
   The ratio tells us if the XR scale is off.
   We also compute how much the current GPS fix would imply the plan
   origin has drifted from its XR position.
   ──────────────────────────────────────────────────────────────── */
function runDriftAnalysis(paired){
  var errors=[];
  for(var i=0;i<paired.length-1;i++){
    for(var j=i+1;j<paired.length;j++){
      var a=paired[i], b=paired[j];
      var gpsDist=haversineM(a.gps.lat,a.gps.lng,b.gps.lat,b.gps.lng);
      var dx=b.world.x-a.world.x, dz=b.world.z-a.world.z;
      var xrDist=Math.sqrt(dx*dx+dz*dz);
      if(xrDist<0.01)continue;
      var ratio=gpsDist/xrDist;     // 1.0 = perfect, >1 XR is compressed, <1 expanded
      var scalePct=Math.abs(ratio-1)*100;
      /* Combined GPS accuracy budget for this pair */
      var accBudget=Math.sqrt(a.gps.acc*a.gps.acc+b.gps.acc*b.gps.acc);
      errors.push({gpsDist:gpsDist,xrDist:xrDist,ratio:ratio,scalePct:scalePct,accBudget:accBudget,i:i,j:j});
    }
  }
  if(errors.length===0)return;

  /* Mean scale error */
  var meanScale=errors.reduce(function(s,e){return s+e.scalePct;},0)/errors.length;
  var meanAcc=errors.reduce(function(s,e){return s+e.accBudget;},0)/errors.length;

  /* Current GPS fix vs nearest waypoint XR anchor — positional drift */
  var driftM=null;
  if(gpsLat!=null&&paired.length>0){
    /* Use WP with best GPS accuracy */
    var best=paired.slice().sort(function(a,b){return a.gps.acc-b.gps.acc;})[0];
    var gpsDelta=haversineM(gpsLat,gpsLng,best.gps.lat,best.gps.lng);
    var bearing=bearingDeg(best.gps.lat,best.gps.lng,gpsLat,gpsLng);
    /* Current XR camera position (approximate — we don't have it directly,
       but we can warn if the GPS delta is large compared to accuracy) */
    driftM=gpsDelta; /* relative to best waypoint GPS origin */
  }

  /* Compose status message */
  var badge=el('gpsDriftBadge');
  var cls='ok', msg='';
  if(meanScale<5&&(driftM==null||driftM<meanAcc)){
    cls='ok';
    msg='\u2714 Scale OK (\u00b1'+meanScale.toFixed(1)+'%) \u2022 GPS ±'+Math.round(meanAcc)+'m';
  } else if(meanScale<15){
    cls='warn';
    msg='\u26A0 Scale drift '+meanScale.toFixed(1)+'% \u2022 GPS ±'+Math.round(meanAcc)+'m';
  } else {
    cls='bad';
    msg='\u26D4 Scale drift '+meanScale.toFixed(1)+'% — check anchors';
  }
  if(driftM!=null&&driftM>meanAcc){
    msg+='\n\u21BA Pos drift ~'+driftM.toFixed(1)+'m from WP1';
    if(cls==='ok')cls='warn';
  }
  badge.textContent=msg; badge.className=''; badge.classList.add('show',cls);
}

/* ── GPS Minimap ── */
function renderMiniMap(){
  if(!gpsEnabled)return;
  var c=el('gpsMapCanvas'), ctx=c.getContext('2d');
  var W=140,H=140;
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle='rgba(4,5,15,.95)'; ctx.fillRect(0,0,W,H);

  /* Grid */
  ctx.strokeStyle='rgba(77,166,255,.1)'; ctx.lineWidth=1;
  for(var g=0;g<W;g+=14){ ctx.beginPath(); ctx.moveTo(g,0); ctx.lineTo(g,H); ctx.stroke(); }
  for(var g2=0;g2<H;g2+=14){ ctx.beginPath(); ctx.moveTo(0,g2); ctx.lineTo(W,g2); ctx.stroke(); }

  /* Cross-hair centre */
  ctx.strokeStyle='rgba(77,166,255,.25)'; ctx.lineWidth=1;
  ctx.beginPath(); ctx.moveTo(W/2,0); ctx.lineTo(W/2,H); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(0,H/2); ctx.lineTo(W,H/2); ctx.stroke();

  if(waypoints.length===0&&gpsLat==null){ return; }

  /* Gather all points including current fix */
  var pts=waypoints.map(function(w){return{lat:w.gps.lat,lng:w.gps.lng,wp:w};});
  if(gpsLat!=null) pts.push({lat:gpsLat,lng:gpsLng,current:true});

  if(pts.length===0)return;

  /* Bounds */
  var lats=pts.map(function(p){return p.lat;}), lngs=pts.map(function(p){return p.lng;});
  var minLat=Math.min.apply(null,lats),maxLat=Math.max.apply(null,lats);
  var minLng=Math.min.apply(null,lngs),maxLng=Math.max.apply(null,lngs);
  var spanLat=maxLat-minLat||0.0001, spanLng=maxLng-minLng||0.0001;
  /* Add 20% padding */
  var padLat=spanLat*0.25, padLng=spanLng*0.25;
  var L0=minLat-padLat, L1=maxLat+padLat, G0=minLng-padLng, G1=maxLng+padLng;

  function toXY(lat,lng){
    return{
      x:(lng-G0)/(G1-G0)*(W-16)+8,
      y:(1-(lat-L0)/(L1-L0))*(H-16)+8
    };
  }

  /* Draw lines between waypoints in order */
  if(waypoints.length>=2){
    ctx.strokeStyle='rgba(77,166,255,.35)'; ctx.lineWidth=1.5; ctx.setLineDash([3,3]);
    ctx.beginPath();
    waypoints.forEach(function(w,i){
      var p=toXY(w.gps.lat,w.gps.lng);
      if(i===0)ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
    });
    ctx.stroke(); ctx.setLineDash([]);
  }

  /* Accuracy circle for current fix */
  if(gpsLat!=null&&gpsAcc!=null){
    var cp=toXY(gpsLat,gpsLng);
    /* convert accuracy to pixels — very rough: 1 deg lat ≈ 111km */
    var accPx=gpsAcc/111000*(H-16)/(L1-L0)*0.5;
    ctx.beginPath(); ctx.arc(cp.x,cp.y,Math.max(3,accPx),0,Math.PI*2);
    ctx.fillStyle='rgba(232,79,43,.08)'; ctx.fill();
    ctx.strokeStyle='rgba(232,79,43,.3)'; ctx.lineWidth=1; ctx.stroke();
  }

  /* Waypoint dots */
  waypoints.forEach(function(w){
    var p=toXY(w.gps.lat,w.gps.lng);
    var hexCol='#'+(WP_COLORS[(w.id-1)%WP_COLORS.length]).toString(16).padStart(6,'0');
    ctx.beginPath(); ctx.arc(p.x,p.y,5,0,Math.PI*2);
    ctx.fillStyle=hexCol; ctx.fill();
    ctx.fillStyle='#fff'; ctx.font='bold 8px monospace';
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(w.id,p.x,p.y);
    /* Accuracy ring */
    if(w.gps.acc!=null){
      var acp=w.gps.acc/111000*(H-16)/(L1-L0)*0.5;
      ctx.beginPath(); ctx.arc(p.x,p.y,Math.max(5,acp),0,Math.PI*2);
      ctx.strokeStyle=hexCol+'55'; ctx.lineWidth=1; ctx.stroke();
    }
  });

  /* Current GPS position */
  if(gpsLat!=null){
    var cp2=toXY(gpsLat,gpsLng);
    ctx.beginPath(); ctx.arc(cp2.x,cp2.y,5,0,Math.PI*2);
    ctx.fillStyle='var(--accent)'; ctx.fill();
    /* Compass direction wedge */
    if(compassHeading!=null){
      var hRad=compassHeading*Math.PI/180;
      ctx.beginPath(); ctx.moveTo(cp2.x,cp2.y);
      ctx.lineTo(cp2.x+Math.sin(hRad)*14,cp2.y-Math.cos(hRad)*14);
      ctx.strokeStyle='rgba(232,79,43,.7)'; ctx.lineWidth=1.5; ctx.stroke();
    }
    /* Label */
    ctx.fillStyle='rgba(232,79,43,.9)'; ctx.font='7px monospace';
    ctx.textAlign='center'; ctx.textBaseline='bottom';
    ctx.fillText('YOU',cp2.x,cp2.y-7);
  }

  /* N arrow */
  ctx.fillStyle='rgba(232,79,43,.7)'; ctx.font='bold 9px monospace';
  ctx.textAlign='left'; ctx.textBaseline='top';
  ctx.fillText('N\u2191',4,4);
}

/* ── Update waypoint DOM labels each frame (project 3D→2D) ── */
function updateWaypointLabels(){
  if(!camera||waypoints.length===0)return;
  waypoints.forEach(function(w){
    if(!w.labelEl||!w.world)return;
    var v=new THREE.Vector3(w.world.x,w.world.y+0.25,w.world.z);
    var proj=v.clone().project(camera);
    if(proj.z>1){ w.labelEl.style.display='none'; return; } /* behind camera */
    var sx=(proj.x*.5+.5)*window.innerWidth;
    var sy=(-.5*proj.y+.5)*window.innerHeight;
    w.labelEl.style.display='';
    w.labelEl.style.left=sx+'px';
    w.labelEl.style.top=sy+'px';
  });
}

/* Clear waypoints on full reset */
function clearWaypoints(){
  waypoints.forEach(function(w){
    if(w.dot&&scene)scene.remove(w.dot);
    if(w.labelEl&&w.labelEl.parentNode)w.labelEl.parentNode.removeChild(w.labelEl);
  });
  waypoints=[];
  var badge=el('gpsDriftBadge'); badge.className=''; badge.textContent='';
  renderMiniMap();
}


function openPickOverlay(){
  uvPicks=[];
  var N=corners.length;
  el('pickTitle').textContent='PICK '+N+' COLUMNS ON THE PLAN';
  el('pickSub').textContent='Tap each column in the SAME ORDER you anchored them \u2022 Column 1 of '+N;
  el('pickInfo').textContent='0 / '+N+' picked';
  el('pickConfirmBtn').disabled=true;

  var maxW=window.innerWidth*0.94, maxH=window.innerHeight*0.58;
  var asp=pdfCanvas.width/pdfCanvas.height;
  var cw=asp>=maxW/maxH?maxW:maxH*asp;
  var ch=asp>=maxW/maxH?maxW/asp:maxH;
  var pc=el('pickCanvas');
  pc.width=Math.round(cw); pc.height=Math.round(ch);
  pc.getContext('2d').drawImage(pdfCanvas,0,0,cw,ch);
  el('pickWrapper').querySelectorAll('.pdot').forEach(function(d){d.parentNode.removeChild(d);});
  el('pickOverlay').classList.add('show');
  // Init ruler after canvas is sized
  setTimeout(function(){initRulerOnCanvas(pc);},50);

  function handleXY(px,py){
    if(uvPicks.length>=corners.length)return;
    var u=Math.max(0,Math.min(1,px/pc.width));
    var v=Math.max(0,Math.min(1,py/pc.height));
    uvPicks.push({u:u,v:v});
    var rawCol=CORNER_COLORS[(uvPicks.length-1)%CORNER_COLORS.length];
    var hexCol='#'+rawCol.toString(16).padStart(6,'0');
    var dot=document.createElement('div');
    dot.className='pdot';
    dot.style.cssText='position:absolute;width:22px;height:22px;border-radius:50%;background:'+hexCol+
      ';color:#000;font-family:Courier New;font-size:10px;font-weight:bold;display:flex;'+
      'align-items:center;justify-content:center;pointer-events:none;transform:translate(-50%,-50%);'+
      'left:'+(px+pc.offsetLeft)+'px;top:'+(py+pc.offsetTop)+'px;z-index:10;';
    dot.textContent=uvPicks.length;
    el('pickWrapper').appendChild(dot);
    var rem=corners.length-uvPicks.length;
    el('pickInfo').textContent=uvPicks.length+' / '+corners.length+' picked';
    el('pickSub').textContent=rem>0?'Column '+(uvPicks.length+1)+' of '+corners.length:'All columns picked \u2014 tap Bind';
    el('pickConfirmBtn').disabled=rem>0;
  }
  pc.ontouchstart=function(e){e.preventDefault();var t=e.changedTouches[0],r=pc.getBoundingClientRect();handleXY(t.clientX-r.left,t.clientY-r.top);};
  pc.onclick=function(e){var r=pc.getBoundingClientRect();handleXY(e.clientX-r.left,e.clientY-r.top);};
}

el('pickUndoBtn').addEventListener('click',function(){
  if(uvPicks.length===0)return;
  uvPicks.pop();
  var dots=el('pickWrapper').querySelectorAll('.pdot');
  if(dots.length>0)dots[dots.length-1].parentNode.removeChild(dots[dots.length-1]);
  el('pickInfo').textContent=uvPicks.length+' / '+corners.length+' picked';
  el('pickSub').textContent='Column '+(uvPicks.length+1)+' of '+corners.length;
  el('pickConfirmBtn').disabled=true;
});
el('pickCancelBtn').addEventListener('click',function(){
  closePickOverlay();
  showBtns('normal');
  el('hudHint').textContent='Tap Anchor to retry';
});
el('pickConfirmBtn').addEventListener('click',function(){
  if(uvPicks.length!==corners.length)return;
  closePickOverlay();
  buildBoundMesh();
});
function closePickOverlay(){
  var pc=el('pickCanvas'); pc.onclick=null; pc.ontouchstart=null;
  el('pickOverlay').classList.remove('show');
}

/* ═══════════════════════════════════════════════════════════════
   KABSCH RIGID-BODY SOLVER
   Finds the best-fit translation + yaw rotation + uniform scale
   that maps plan UV points → world XZ points.
   Returns {origin, yaw, scale, residualM} or null.

   Algorithm:
     1. Centre both point sets on their centroids
     2. Build 2×2 cross-covariance matrix H = Σ uvᵢᵀ · wᵢ
     3. SVD of H → U, S, Vᵀ  (2D: analytical formula)
     4. R = V · Uᵀ  (optimal rotation)
     5. Scale = Σ|wᵢ|² / Σ(uᵢ·Rᵀ·wᵢ)  (TLS scale)
     6. Translation from centroids
   ══════════════════════════════════════════════════════════════ */
function kabschSolve(corners, uvPicks){
  var N=corners.length;
  if(N<2) return null;

  /* Collect 2D points — world XZ and plan UV (centred on 0.5,0.5) */
  var wx=[],wz=[],pu=[],pv=[];
  for(var i=0;i<N;i++){
    wx.push(corners[i].worldPos.x); wz.push(corners[i].worldPos.z);
    pu.push(uvPicks[i].u-0.5);      pv.push(uvPicks[i].v-0.5);
  }

  /* Centroids */
  var cwx=wx.reduce(function(a,b){return a+b;},0)/N;
  var cwz=wz.reduce(function(a,b){return a+b;},0)/N;
  var cpu=pu.reduce(function(a,b){return a+b;},0)/N;
  var cpv=pv.reduce(function(a,b){return a+b;},0)/N;

  /* Centred coords */
  var Wx=wx.map(function(v){return v-cwx;});
  var Wz=wz.map(function(v){return v-cwz;});
  var Pu=pu.map(function(v){return v-cpu;});
  var Pv=pv.map(function(v){return v-cpv;});

  /* 2D cross-covariance H = Pᵀ W  (2×2) */
  var h00=0,h01=0,h10=0,h11=0;
  for(var i=0;i<N;i++){
    h00+=Pu[i]*Wx[i]; h01+=Pu[i]*Wz[i];
    h10+=Pv[i]*Wx[i]; h11+=Pv[i]*Wz[i];
  }

  /* Analytical SVD of 2×2 matrix H:
     θ = 0.5·atan2(2·(h00·h10+h01·h11), h00²+h01²-h10²-h11²) */
  var theta=0.5*Math.atan2(2*(h00*h10+h01*h11),
                           h00*h00+h01*h01-h10*h10-h11*h11);
  var cosT=Math.cos(theta), sinT=Math.sin(theta);
  /* U = rotation matrix from theta */
  /* V from: H = U·S·Vᵀ  → Vᵀ = S⁻¹·Uᵀ·H (approximate — use atan2 of H·U) */
  var phi=Math.atan2(h10*cosT+h11*sinT, h00*cosT+h01*sinT);
  var cosP=Math.cos(phi), sinP=Math.sin(phi);

  /* Optimal rotation: R = V·Uᵀ → yaw angle = phi - theta */
  var yaw=phi-theta;

  /* Ensure det(R)>0 (no reflection) */
  var detR=Math.cos(yaw);  /* det of 2D rotation = 1, always positive */

  /* Optimal scale: s = Σ(W·R·P) / Σ|P|² */
  var num=0, den=0;
  var cosY=Math.cos(yaw), sinY=Math.sin(yaw);
  for(var i=0;i<N;i++){
    var Ru=cosY*Pu[i]-sinY*Pv[i];
    var Rv=sinY*Pu[i]+cosY*Pv[i];
    num+=Wx[i]*Ru+Wz[i]*Rv;
    den+=Pu[i]*Pu[i]+Pv[i]*Pv[i];
  }
  var scale=(den>1e-10)?num/den:1;
  if(scale<0.01||scale>500) return null;  /* degenerate */

  /* Translation: t = Wcent - s·R·Pcent */
  var Rpu=cosY*cpu-sinY*cpv;
  var Rpv=sinY*cpu+cosY*cpv;
  var tx=cwx-scale*Rpu;
  var tz=cwz-scale*Rpv;

  /* Residual: mean reprojection error in metres */
  var resSum=0;
  for(var i=0;i<N;i++){
    var rpx=scale*(cosY*pu[i]-sinY*pv[i])+tx;
    var rpz=scale*(sinY*pu[i]+cosY*pv[i])+tz;
    var dx=wx[i]-rpx, dz=wz[i]-rpz;
    resSum+=Math.sqrt(dx*dx+dz*dz);
  }
  var residualM=resSum/N;

  return {tx:tx, tz:tz, yaw:yaw, scale:scale, residualM:residualM};
}

/* ═══════════════════════════════════════════════════════════════
   PLAN MESH GEOMETRY  (flat rectangle, UV 0-1 covering whole PDF)
   The mesh itself never deforms — we just move/rotate/scale the
   THREE.Group that holds it.
   ══════════════════════════════════════════════════════════════ */
var planRigidGroup=null;   /* THREE.Group positioned by Kabsch each frame */

function buildBoundMesh(){
  if(corners.length<2||uvPicks.length!==corners.length){
    showToast('Need at least 2 column anchors'); showBtns('normal'); return;
  }
  if(boundMesh&&scene){scene.remove(boundMesh);boundMesh=null;}
  if(planRigidGroup&&scene){scene.remove(planRigidGroup);planRigidGroup=null;}
  if(renderer){
    var maxTex=renderer.capabilities.maxTextureSize;
    if(pdfCanvas.width>maxTex||pdfCanvas.height>maxTex){
      var r=Math.min(maxTex/pdfCanvas.width,maxTex/pdfCanvas.height);
      var t=document.createElement('canvas');
      t.width=Math.floor(pdfCanvas.width*r); t.height=Math.floor(pdfCanvas.height*r);
      t.getContext('2d').drawImage(pdfCanvas,0,0,t.width,t.height); pdfCanvas=t;
    }
  }
  var tex=new THREE.Texture(pdfCanvas);
  tex.needsUpdate=true; tex.anisotropy=renderer?renderer.capabilities.getMaxAnisotropy():1;
  tex.minFilter=THREE.LinearMipmapLinearFilter; tex.magFilter=THREE.LinearFilter; tex.generateMipmaps=true;

  /* A flat plane: 1 UV unit = 1 metre initially; Kabsch scale corrects this.
     Plane is in XZ, centred at origin, UV 0,0 = bottom-left of PDF.         */
  var asp=pdfCanvas.width/pdfCanvas.height;
  var geo=new THREE.PlaneGeometry(asp,1,1,1);
  geo.applyMatrix4(new THREE.Matrix4().makeRotationX(-Math.PI/2));
  /* Flip UV V so PDF top = world north when yaw=0 */
  var uvAttr=geo.attributes.uv;
  for(var i=0;i<uvAttr.count;i++) uvAttr.setY(i,1-uvAttr.getY(i));
  uvAttr.needsUpdate=true;

  var mat=new THREE.MeshBasicMaterial({map:tex,transparent:true,opacity:xfOpacity,
                                        side:THREE.DoubleSide,depthWrite:false});
  boundMesh=new THREE.Mesh(geo,mat);

  planRigidGroup=new THREE.Group();
  planRigidGroup.add(boundMesh);
  scene.add(planRigidGroup);
  if(planeGroup)planeGroup.visible=false;

  /* Initial Kabsch solve */
  if(!reSolvePlan()){
    /* Fallback if only 2 points — place centred between them */
    planBound=true;
    applyRigidTransform(planOrigin.x,planOrigin.z,planYaw,planScale);
  }

  show('statusBar'); show('cornerBadge');
  el('cornerBadge').textContent='\u2714 Locked \u2022 '+corners.length+' column anchors';
  showBtns('normal');
  el('hudHint').textContent='Plan structure-locked \u2714 \u2022 All sensors active';
  showToast('Plan rigid-locked to '+corners.length+' columns \u2714',4000);
}

/* Apply the Kabsch transform to the planRigidGroup */
function applyRigidTransform(tx,tz,yaw,scale){
  if(!planRigidGroup)return;
  /* Y position: mean column Y */
  var meanY=corners.reduce(function(s,c){return s+c.worldPos.y;},0)/Math.max(corners.length,1);
  planRigidGroup.position.set(tx,meanY,tz);
  planRigidGroup.rotation.set(0,yaw,0);
  planRigidGroup.scale.set(scale,1,scale);
}

/* Run Kabsch → update plan transform → update status panel */
function reSolvePlan(){
  var t0=performance.now();
  var sol=kabschSolve(corners,uvPicks);
  if(!sol) return false;
  planOrigin.set(sol.tx,0,sol.tz);
  planYaw=sol.yaw;
  planScale=sol.scale;
  planBound=true;
  applyRigidTransform(sol.tx,sol.tz,sol.yaw,sol.scale);
  solveCount++;
  var ms=(performance.now()-t0).toFixed(1);
  var resStr=sol.residualM<0.005?'\u2714':sol.residualM<0.05?'\u26A0':'!';
  el('statusBar').textContent=
    corners.length+' col \u2022 res '+( sol.residualM*100).toFixed(1)+'cm '+resStr+
    ' \u2022 scale '+(sol.scale).toFixed(3)+'m/UV'+
    ' \u2022 #'+solveCount+' ('+ms+'ms)';
  constraintQuality.xrAnchor=Math.max(0,1-sol.residualM/0.1);
  updateConstraintPanel();
  return true;
}

/* ═══════════════════════════════════════════════════════════════
   XR ANCHOR UPDATE  (called every frame when plan is bound)
   1. Pull updated anchor positions
   2. Re-snap columns to plane vertices every RESNAP_INTERVAL frames
   3. Re-run Kabsch if anything moved
   ══════════════════════════════════════════════════════════════ */
function updateAnchors(frame,refSpace){
  var moved=false;

  /* 1. XRAnchors drift correction */
  corners.forEach(function(c){
    if(!c.anchor)return;
    try{
      var ap=frame.getPose(c.anchor.anchorSpace,refSpace);
      if(!ap)return;
      var nx=ap.transform.position.x,ny=ap.transform.position.y,nz=ap.transform.position.z;
      if(Math.abs(nx-c.worldPos.x)+Math.abs(ny-c.worldPos.y)+Math.abs(nz-c.worldPos.z)>0.0005){
        c.worldPos={x:nx,y:ny,z:nz}; moved=true;
      }
    }catch(e){}
  });

  /* 2. Periodic plane-vertex re-snap */
  reSnapFrameCounter++;
  if(reSnapFrameCounter>=RESNAP_INTERVAL){
    reSnapFrameCounter=0;
    var snapMoved=false;
    corners.forEach(function(c){
      var pos=new THREE.Vector3(c.worldPos.x,c.worldPos.y,c.worldPos.z);
      var snapped=snapToNearestPlaneVertex(pos,frame,refSpace);
      if(!snapped)return;
      var dx=snapped.x-c.worldPos.x, dz=snapped.z-c.worldPos.z;
      var dist=Math.sqrt(dx*dx+dz*dz);
      if(dist>0.005&&dist<RESNAP_THRESHOLD){
        /* Silent correction — within tolerance */
        c.worldPos.x=snapped.x; c.worldPos.z=snapped.z;
        snapMoved=true; moved=true;
        constraintQuality.planeSnap=1.0;
      } else if(dist>=RESNAP_THRESHOLD){
        /* Too large — flag but don't apply */
        constraintQuality.planeSnap=Math.max(0,1-dist/0.5);
      } else {
        constraintQuality.planeSnap=1.0;
      }
    });
  }

  /* 3. Apply heading constraint from fused compass */
  if(planBound&&headingLocked&&fusedHeading!=null){
    /* fusedHeading is the plan's North-up bearing.
       We only correct yaw by a small lerp each frame to avoid jumps.
       Target yaw = fusedHeading in radians                           */
    var targetYaw=fusedHeading*Math.PI/180;
    var diff=targetYaw-planYaw;
    while(diff>Math.PI)diff-=2*Math.PI; while(diff<-Math.PI)diff+=2*Math.PI;
    /* Lerp weight: 0.008 per frame = ~0.5% correction → smooth but firm */
    planYaw+=diff*0.008;
    if(planRigidGroup) planRigidGroup.rotation.y=planYaw;
    moved=true;
  }

  return moved;
}

/* ═══════════════════════════════════════════════════════════════
   COMPLEMENTARY FILTER — HEADING FUSION
   Called from deviceorientation events (set up in startCompass).
   Fuses gyroscope delta (smooth) with compass absolute (stable).
   ══════════════════════════════════════════════════════════════ */
function updateFusedHeading(compassAbs, alphaRaw, ts){
  if(fusedHeading===null){
    /* Cold start — trust compass outright */
    fusedHeading=compassAbs;
    lastAlpha=alphaRaw; lastGyroTime=ts;
    headingLocked=true;
    constraintQuality.compass=0.6;
    return;
  }
  /* Gyro delta: alpha changes at device rotation rate.
     On Android alpha is NOT absolute — use delta only.
     Handle wrap-around.                                  */
  var dt=Math.min((ts-lastGyroTime)/1000, 0.1);  /* cap at 100ms */
  var dAlpha=alphaRaw-(lastAlpha||alphaRaw);
  while(dAlpha>180)dAlpha-=360; while(dAlpha<-180)dAlpha+=360;
  lastAlpha=alphaRaw; lastGyroTime=ts;
  gyroRate=dAlpha/Math.max(dt,0.001);

  /* Gyro prediction */
  var gyroPredict=fusedHeading-dAlpha;  /* alpha increases CCW → negate */
  while(gyroPredict<0)gyroPredict+=360; while(gyroPredict>=360)gyroPredict-=360;

  /* Compass wrap-aware blend */
  var compassDiff=compassAbs-gyroPredict;
  while(compassDiff>180)compassDiff-=360; while(compassDiff<-180)compassDiff+=360;
  fusedHeading=gyroPredict+COMPASS_ALPHA*compassDiff;
  while(fusedHeading<0)fusedHeading+=360; while(fusedHeading>=360)fusedHeading-=360;

  headingLocked=true;
  /* Quality: higher if compass and gyro agree */
  var agree=1-Math.abs(compassDiff)/180;
  constraintQuality.compass=0.7*constraintQuality.compass+0.3*agree;

  /* Update GPS bearing reference if we have it */
  if(gpsBearingRef!=null){
    /* Cross-check: if fused heading disagrees with GPS bearing by >15°, warn */
    var gpsDiff=Math.abs(fusedHeading-gpsBearingRef.heading);
    while(gpsDiff>180)gpsDiff=360-gpsDiff;
    constraintQuality.gpsBearing=gpsDiff<15?1:Math.max(0,1-gpsDiff/45);
  }

  if(planBound) updateConstraintPanel();
}

/* ═══════════════════════════════════════════════════════════════
   GPS BEARING REFINEMENT
   Every time a new GPS fix arrives, push to rolling buffer.
   If two fixes are >2m apart, compute the bearing and store it
   as a reference heading constraint.
   ══════════════════════════════════════════════════════════════ */
function ingestGPSForBearing(lat,lng,acc){
  if(acc>20) return;  /* only use accurate fixes */
  gpsBearingFixes.push({lat:lat,lng:lng,ts:Date.now()});
  if(gpsBearingFixes.length>8) gpsBearingFixes.shift();
  /* Find pair with largest separation */
  var bestDist=2.0, bestBearing=null;  /* require at least 2m */
  for(var i=0;i<gpsBearingFixes.length-1;i++){
    for(var j=i+1;j<gpsBearingFixes.length;j++){
      var a=gpsBearingFixes[i], b=gpsBearingFixes[j];
      var d=haversineM(a.lat,a.lng,b.lat,b.lng);
      if(d>bestDist){
        bestDist=d;
        bestBearing=bearingDeg(a.lat,a.lng,b.lat,b.lng);
      }
    }
  }
  if(bestBearing!==null){
    /* confidence scales with distance: 2m=0.4, 10m=1.0 */
    var conf=Math.min(1,(bestDist-2)/8*0.6+0.4);
    gpsBearingRef={heading:bestBearing,distance:bestDist,confidence:conf};
    constraintQuality.gpsBearing=conf;
    /* Nudge fused heading toward GPS bearing if confidence is high */
    if(fusedHeading!==null&&conf>0.6){
      var gd=bestBearing-fusedHeading;
      while(gd>180)gd-=360; while(gd<-180)gd+=360;
      fusedHeading+=gd*conf*0.1;
    }
    updateConstraintPanel();
  }
}

/* ═══════════════════════════════════════════════════════════════
   CONSTRAINT QUALITY PANEL  (updates the statusBar)
   ══════════════════════════════════════════════════════════════ */
function qualBar(q){
  var n=Math.round(q*5);
  var filled='\u2588'.repeat(n), empty='\u2591'.repeat(5-n);
  return filled+empty;
}
function updateConstraintPanel(){
  if(!planBound)return;
  var lines=[
    'XR  anchors  '+qualBar(constraintQuality.xrAnchor),
    'Compass      '+qualBar(constraintQuality.compass)+(fusedHeading!=null?' '+Math.round(fusedHeading)+'\u00b0':''),
    'GPS bearing  '+qualBar(constraintQuality.gpsBearing)+(gpsBearingRef?' '+Math.round(gpsBearingRef.distance)+'m':''),
    'Plane snap   '+qualBar(constraintQuality.planeSnap),
  ];
  /* Overall lock quality — weighted average */
  var overall=(constraintQuality.xrAnchor*0.35+constraintQuality.compass*0.30+
               constraintQuality.gpsBearing*0.15+constraintQuality.planeSnap*0.20);
  var overallStr=overall>0.75?'\u2714 Stable':overall>0.45?'\u26A0 Partial':'\u26D4 Weak';
  el('statusBar').textContent=overallStr+'  \u2022  solve #'+solveCount+'\n'+lines.join('  |  ');
  el('statusBar').style.whiteSpace='pre';
  el('driftBadge').textContent=(overall>0.75?'\u2714':'\u26A0')+' Lock '+Math.round(overall*100)+'%';
  show('driftBadge');
}

/* ═══════════════════════════════
   WEBXR
═══════════════════════════════ */
function startWebXR(){
  var canvas=el('arCanvas');
  renderer=new THREE.WebGLRenderer({canvas:canvas,alpha:true,antialias:true});
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth,window.innerHeight);
  renderer.xr.enabled=true;

  scene=new THREE.Scene();
  camera=new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,0.01,200);
  scene.add(new THREE.AmbientLight(0xffffff,1));

  var maxTex=renderer.capabilities.maxTextureSize;
  if(pdfCanvas.width>maxTex||pdfCanvas.height>maxTex){
    var rr=Math.min(maxTex/pdfCanvas.width,maxTex/pdfCanvas.height);
    var tt=document.createElement('canvas');
    tt.width=Math.floor(pdfCanvas.width*rr); tt.height=Math.floor(pdfCanvas.height*rr);
    tt.getContext('2d').drawImage(pdfCanvas,0,0,tt.width,tt.height); pdfCanvas=tt;
  }

  /* Reticle */
  reticle=new THREE.Group(); reticle.matrixAutoUpdate=false; reticle.visible=false;
  var rRing=new THREE.RingGeometry(0.10,0.13,48);
  rRing.applyMatrix4(new THREE.Matrix4().makeRotationX(-Math.PI/2));
  reticle.add(new THREE.Mesh(rRing,new THREE.MeshBasicMaterial({color:0xe84f2b,side:THREE.DoubleSide})));
  var rDot=new THREE.CircleGeometry(0.016,20);
  rDot.applyMatrix4(new THREE.Matrix4().makeRotationX(-Math.PI/2));
  reticle.add(new THREE.Mesh(rDot,new THREE.MeshBasicMaterial({color:0xe84f2b})));
  var lm=new THREE.LineBasicMaterial({color:0xe84f2b,transparent:true,opacity:0.6});
  [[1,0,0],[-1,0,0],[0,0,1],[0,0,-1]].forEach(function(d){
    var lg=new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(d[0]*.04,d[1]*.04,d[2]*.04),new THREE.Vector3(d[0]*.16,d[1]*.16,d[2]*.16)]);
    reticle.add(new THREE.Line(lg,lm));
  });
  scene.add(reticle);

  /* Free plan */
  var asp=pdfCanvas.width/pdfCanvas.height;
  planeGroup=new THREE.Group(); planeGroup.visible=false; scene.add(planeGroup);
  var freeGeo=new THREE.PlaneGeometry(asp,1);
  freeGeo.applyMatrix4(new THREE.Matrix4().makeRotationX(-Math.PI/2));
  var freeTex=new THREE.Texture(pdfCanvas);
  freeTex.needsUpdate=true; freeTex.anisotropy=renderer.capabilities.getMaxAnisotropy();
  freeTex.minFilter=THREE.LinearMipmapLinearFilter; freeTex.magFilter=THREE.LinearFilter; freeTex.generateMipmaps=true;
  planeMesh=new THREE.Mesh(freeGeo,new THREE.MeshBasicMaterial({map:freeTex,transparent:true,opacity:xfOpacity,side:THREE.DoubleSide,depthWrite:false}));
  planeMesh.scale.set(xfScaleM,1,xfScaleM); planeGroup.add(planeMesh);

  /* Session */
  navigator.xr.requestSession('immersive-ar',{
    requiredFeatures:['hit-test'],
    optionalFeatures:['plane-detection','anchors','dom-overlay'],
    domOverlay:{root:el('xrOverlay')}   // ← the FULL overlay div, not just #hud
  }).then(function(session){
    xrSession=session;
    renderer.xr.setReferenceSpaceType('local');
    renderer.xr.setSession(session);
    session.requestReferenceSpace('viewer').then(function(vs){
      session.requestHitTestSource({space:vs}).then(function(src){xrHitTestSrc=src;});
    });
    session.requestReferenceSpace('local').then(function(rs){
      xrRefSpace=rs;
      renderer.setAnimationLoop(function(t,frame){xrFrame(frame);});
    });

    /* SELECT */
    session.addEventListener('select',function(){
      if(!reticle.visible)return;
      var rx=reticle.matrix.elements[12],ry=reticle.matrix.elements[13],rz=reticle.matrix.elements[14];

      /* MEASURE MODE */
      if(measureMode){
        var fp=currentSnap?{x:currentSnap.x,y:currentSnap.y,z:currentSnap.z}:{x:rx,y:ry,z:rz};
        if(!measurePt1){
          measurePt1=fp;
          var dot=new THREE.Mesh(new THREE.SphereGeometry(0.028,10,10),new THREE.MeshBasicMaterial({color:0xf0d060}));
          dot.position.set(fp.x,fp.y+0.028,fp.z); scene.add(dot); measureDots.push(dot);
          el('hudHint').textContent='Tap floor for point 2\u2026';
        } else {
          measurePt2=fp;
          buildMeasureLine(measurePt1,measurePt2);
          updateMeasureLabel(measurePt1,measurePt2);
          measurePt1=null; measurePt2=null; // allow re-measure
          el('hudHint').textContent='Tap to measure again or Done';
        }
        return;
      }

      /* ANCHOR MODE: place column anchor */
      if(traceMode){
        if(corners.length>=MAX_CORNERS){showToast('Max '+MAX_CORNERS+' column anchors');return;}
        var fp=currentSnap?{x:currentSnap.x,y:currentSnap.y,z:currentSnap.z}:{x:rx,y:ry,z:rz};
        var corner={worldPos:fp,anchor:null};
        corners.push(corner);
        addCornerVisual(fp,corners.length-1);
        updateCornerBadge();
        showToast(currentSnap?'Column '+corners.length+' \u2014 snapped to structure \u2713':'Column '+corners.length+' anchored');
        /* XRAnchor */
        if(typeof session.createAnchor==='function'){
          try{
            var cidx=corners.length-1;
            session.createAnchor(new XRRigidTransform(new DOMPointReadOnly(fp.x,fp.y,fp.z,1),new DOMPointReadOnly(0,0,0,1)),xrRefSpace)
              .then(function(a){corners[cidx].anchor=a;}).catch(function(){});
          }catch(e){}
        }
        return;
      }

      /* INITIAL PLACEMENT */
      if(wxrPlaced)return;
      var q=new THREE.Quaternion();
      new THREE.Matrix4().fromArray(reticle.matrix.elements).decompose(new THREE.Vector3(),q,new THREE.Vector3());
      planeGroup.position.set(rx,ry,rz); planeGroup.quaternion.copy(q); planeGroup.visible=true;
      surfaceQuat.copy(q); wxrPlaced=true;
      floorPlane.setFromNormalAndCoplanarPoint(new THREE.Vector3(0,1,0).applyQuaternion(q).normalize(),new THREE.Vector3(rx,ry,rz));
      applyFree(); hide('scanRing');
      el('hudHint').textContent='Plan placed \u2022 Tap Anchor to bind to columns';
      showToast('Placed \u2014 tap Anchor, walk to each column base and tap');
      xfLocked=true; el('lockBtn').textContent='\uD83D\uDD12 Locked'; el('lockBtn').className='hud-btn g';
    });

    /* Touch pan / pinch */
    var tMap={},panRC=new THREE.Raycaster(),panTgt=new THREE.Vector3();
    window.addEventListener('touchstart',function(e){for(var i=0;i<e.changedTouches.length;i++){var t=e.changedTouches[i];tMap[t.identifier]={x:t.clientX,y:t.clientY};}},{passive:true});
    window.addEventListener('touchmove',function(e){
      if(!wxrPlaced||traceMode||boundMesh)return;
      for(var i=0;i<e.changedTouches.length;i++){var t=e.changedTouches[i];tMap[t.identifier]={x:t.clientX,y:t.clientY};}
      var pts=Object.values(tMap);
      if(pts.length===1&&!xfLocked){
        var pt=pts[0];
        panRC.setFromCamera({x:(pt.x/window.innerWidth)*2-1,y:-((pt.y/window.innerHeight)*2-1)},camera);
        if(panRC.ray.intersectPlane(floorPlane,panTgt)){planeGroup.position.copy(panTgt);floorPlane.setFromNormalAndCoplanarPoint(floorPlane.normal,panTgt);}
        return;
      }
      if(pts.length>=2){
        var a=pts[0],b=pts[1],dx=b.x-a.x,dy=b.y-a.y;
        var dist=Math.sqrt(dx*dx+dy*dy),ang=Math.atan2(dy,dx);
        if(prevPinchDist!==null){
          xfScaleM=Math.max(0.05,Math.min(500,xfScaleM*(dist/prevPinchDist)));
          planeMesh.scale.set(xfScaleM,1,xfScaleM);
          var da=ang-prevPinchAngle; while(da>Math.PI)da-=2*Math.PI; while(da<-Math.PI)da+=2*Math.PI;
          xfRotY-=da; applyFree();
        }
        prevPinchDist=dist; prevPinchAngle=ang;
      }
    },{passive:true});
    window.addEventListener('touchend',function(e){for(var i=0;i<e.changedTouches.length;i++)delete tMap[e.changedTouches[i].identifier];if(Object.keys(tMap).length<2){prevPinchDist=null;prevPinchAngle=null;}},{passive:true});

    session.addEventListener('end',function(){renderer.setAnimationLoop(null);});
    show('scanRing');
    el('hudHint').textContent='Slowly scan the ground\u2026';
    /* Auto-align to compass heading on first surface detection if available */
    if(compassHeading!=null){ xfRotY=compassHeading*Math.PI/180; }

  }).catch(function(err){el('hudHint').textContent='AR error: '+err.message;console.error(err);});
}

/* ═══════════════════════════════
   XR FRAME LOOP
═══════════════════════════════ */
function xrFrame(frame){
  if(!frame)return;
  renderer.render(scene,camera);

  /* Update measure label position (project to screen each frame) */
  if(measureLine&&camera){
    var ma=measureLine.geometry.attributes.position;
    if(ma&&ma.count>=2){
      var wA={x:ma.getX(0),y:ma.getY(0)+0.04,z:ma.getZ(0)};
      var wB={x:ma.getX(1),y:ma.getY(1)+0.04,z:ma.getZ(1)};
      updateMeasureLabel(wA,wB);
    }
  }

  /* Update GPS waypoint label screen positions */
  updateWaypointLabels();

  /* Update plane wireframes */
  if(xrRefSpace){
    try{updatePlaneWireframes(frame,xrRefSpace);}catch(e){}
  }

  if(!xrHitTestSrc||!xrRefSpace)return;
  var hits=frame.getHitTestResults(xrHitTestSrc);
  if(hits.length>0){
    var pose=hits[0].getPose(xrRefSpace);
    reticle.visible=true;
    reticle.matrix.fromArray(pose.transform.matrix);

    var hitPos=new THREE.Vector3(pose.transform.position.x,pose.transform.position.y,pose.transform.position.z);

    /* Plane snap during tracing */
    if(traceMode){
      var snapped=snapToNearestPlaneVertex(hitPos,frame,xrRefSpace);
      if(snapped){
        currentSnap=snapped;
        reticle.matrix.elements[12]=snapped.x;
        reticle.matrix.elements[13]=snapped.y;
        reticle.matrix.elements[14]=snapped.z;
        show('snapIndicator');
        el('snapCircle').setAttribute('stroke','#2be87a'); el('snapV').setAttribute('stroke','#2be87a');
        el('snapH').setAttribute('stroke','#2be87a'); el('snapDot').setAttribute('fill','#2be87a');
      }else{
        currentSnap=null; hide('snapIndicator');
        el('snapCircle').setAttribute('stroke','#4da6ff'); el('snapV').setAttribute('stroke','#4da6ff');
        el('snapH').setAttribute('stroke','#4da6ff'); el('snapDot').setAttribute('fill','#4da6ff');
      }
    }

    if(!wxrFloorFound){
      wxrFloorFound=true; show('planeBadge');
      el('hudHint').textContent=traceMode?'Walk to column base and tap':'Tap to place plan';
      setTimeout(function(){hide('planeBadge');},4000);
    }
  }else{
    reticle.visible=false; currentSnap=null;
    if(traceMode)hide('snapIndicator');
    if(!wxrPlaced){wxrFloorFound=false; el('hudHint').textContent='Slowly scan the ground\u2026';}
  }

  /* Anchor drift correction + full constraint fusion */
  if(planBound&&corners.length>0){
    if(updateAnchors(frame,xrRefSpace)){
      reSolvePlan();
    }
  }
}

})();
</script>
</body>
</html>
