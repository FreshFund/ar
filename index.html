<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>AR Floorplan Â· Anchored</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400&family=Syne:wght@700;800&display=swap" rel="stylesheet">
<style>
* { margin:0; padding:0; box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
:root {
  --ink:#04050f; --paper:#e8e4db; --accent:#e84f2b;
  --green:#2be87a; --blue:#4da6ff; --yellow:#f0d060;
  --mono:'Space Mono',monospace;
  --display:'Syne',sans-serif;
}
html,body { height:100%; overflow:hidden; background:var(--ink); color:var(--paper); font-family:var(--mono); }

/* â”€â”€ LANDING â”€â”€ */
#landing {
  position:fixed; inset:0; display:flex; flex-direction:column;
  align-items:center; justify-content:center; padding:24px;
  background:var(--ink); z-index:100; overflow-y:auto;
}

/* Animated grid background */
#landing::before {
  content:''; position:absolute; inset:0; z-index:0;
  background-image:
    linear-gradient(rgba(232,79,43,.06) 1px, transparent 1px),
    linear-gradient(90deg, rgba(232,79,43,.06) 1px, transparent 1px);
  background-size:48px 48px;
  animation:gridDrift 18s linear infinite;
}
#landing::after {
  content:''; position:absolute; inset:0; z-index:0;
  background: radial-gradient(ellipse 70% 60% at 50% 50%, rgba(232,79,43,.08) 0%, transparent 70%),
              radial-gradient(ellipse 40% 40% at 15% 80%, rgba(77,166,255,.06) 0%, transparent 60%),
              radial-gradient(ellipse 50% 40% at 85% 20%, rgba(43,232,122,.05) 0%, transparent 60%);
  pointer-events:none;
}
@keyframes gridDrift { from{background-position:0 0} to{background-position:48px 48px} }

.landing-inner {
  position:relative; z-index:1; width:100%; max-width:520px;
  display:flex; flex-direction:column; align-items:center;
}

/* Top nav bar */
.l-nav {
  width:100%; display:flex; align-items:center; justify-content:space-between;
  margin-bottom:52px; border-bottom:1px solid rgba(232,79,43,.2); padding-bottom:14px;
}
.l-logo {
  font-family:var(--display); font-size:13px; font-weight:800; letter-spacing:.06em;
  color:var(--paper); text-transform:uppercase;
}
.l-logo span { color:var(--accent); }
.l-badge {
  font-size:9px; letter-spacing:.3em; text-transform:uppercase;
  padding:4px 10px; border:1px solid rgba(43,232,122,.4); color:var(--green);
  border-radius:100px; background:rgba(43,232,122,.06);
  animation:badgePulse 2.4s ease-in-out infinite;
}
@keyframes badgePulse { 0%,100%{opacity:.6} 50%{opacity:1} }

/* Main headline */
.l-headline {
  font-family:var(--display); font-weight:800;
  font-size:clamp(36px,10vw,72px); line-height:.9;
  text-align:center; letter-spacing:-.02em;
  margin-bottom:10px;
  animation:fadeUp .7s cubic-bezier(.16,1,.3,1) both;
}
.l-headline .line2 { display:block; color:var(--accent); font-style:italic; }
@keyframes fadeUp { from{opacity:0;transform:translateY(20px)} to{opacity:1;transform:translateY(0)} }

.l-sub {
  font-size:11px; letter-spacing:.18em; text-transform:uppercase;
  color:rgba(232,228,219,.38); margin-bottom:36px;
  animation:fadeUp .7s .12s cubic-bezier(.16,1,.3,1) both;
}

/* Feature tags */
.l-tags {
  display:flex; gap:8px; flex-wrap:wrap; justify-content:center;
  margin-bottom:36px;
  animation:fadeUp .7s .22s cubic-bezier(.16,1,.3,1) both;
}
.l-tag {
  font-size:9px; letter-spacing:.22em; text-transform:uppercase;
  padding:5px 12px; border-radius:100px;
  border:1px solid rgba(255,255,255,.1); color:rgba(232,228,219,.5);
  background:rgba(255,255,255,.03);
}
.l-tag.hi { border-color:rgba(77,166,255,.35); color:var(--blue); background:rgba(77,166,255,.06); }

/* Drop zone */
.drop-zone {
  width:100%; border:1px solid rgba(232,79,43,.25);
  background:rgba(232,79,43,.03);
  border-radius:4px; padding:28px 20px; text-align:center; cursor:pointer;
  transition:border-color .2s, background .2s, box-shadow .2s;
  position:relative; overflow:hidden;
  animation:fadeUp .7s .32s cubic-bezier(.16,1,.3,1) both;
}
.drop-zone::before {
  content:''; position:absolute; inset:0;
  background:linear-gradient(135deg, transparent 40%, rgba(232,79,43,.04) 100%);
  pointer-events:none;
}
.drop-zone:hover, .drop-zone.over {
  border-color:var(--accent); background:rgba(232,79,43,.07);
  box-shadow:0 0 32px rgba(232,79,43,.12), inset 0 0 24px rgba(232,79,43,.04);
}
.drop-icon { font-size:28px; display:block; margin-bottom:9px; filter:grayscale(.4); }
.drop-label { font-size:11px; letter-spacing:.22em; text-transform:uppercase; margin-bottom:5px; color:var(--paper); }
.drop-sub { font-size:10px; color:rgba(232,228,219,.32); letter-spacing:.1em; }
#fileInput { display:none; }

/* Thumb preview */
#pdfThumb {
  display:none; margin-top:14px; max-width:100%; max-height:110px;
  border:1px solid rgba(255,255,255,.1); border-radius:2px;
}
#pageNav { display:none; align-items:center; gap:12px; margin-top:8px; font-size:11px; }
.pg-btn {
  background:none; border:1px solid rgba(255,255,255,.2); color:var(--paper);
  width:28px; height:28px; cursor:pointer; font-size:15px; font-family:var(--mono);
  border-radius:2px; transition:border-color .15s, color .15s;
}
.pg-btn:hover { border-color:var(--accent); color:var(--accent); }

/* Launch button */
#launchBtn {
  display:none; margin-top:18px; position:relative; overflow:hidden;
  background:var(--accent); color:#fff;
  border:none; padding:16px 48px; font-family:var(--mono); font-size:11px;
  letter-spacing:.32em; text-transform:uppercase; cursor:pointer;
  border-radius:2px; transition:background .2s, box-shadow .2s;
  animation:fadeUp .5s .4s cubic-bezier(.16,1,.3,1) both;
}
#launchBtn::after {
  content:''; position:absolute; inset:0;
  background:linear-gradient(90deg, transparent, rgba(255,255,255,.15), transparent);
  transform:translateX(-100%); transition:transform .5s;
}
#launchBtn:hover::after { transform:translateX(100%); }
#launchBtn.show { display:block; }
#launchBtn:hover { background:#c83d1e; box-shadow:0 0 28px rgba(232,79,43,.35); }

.note {
  margin-top:14px; font-size:10px; color:rgba(232,228,219,.2);
  letter-spacing:.07em; text-align:center; max-width:380px; line-height:1.9;
  animation:fadeUp .7s .45s cubic-bezier(.16,1,.3,1) both;
}
#errMsg { display:none; margin-top:10px; font-size:11px; color:var(--accent); letter-spacing:.08em; }

/* â”€â”€ AR SCREEN â”€â”€ */
#arScreen { display:none; position:fixed; inset:0; z-index:200; background:#000; }
#arCanvas { width:100%; height:100%; display:block; }

/* â”€â”€ DOM OVERLAY ROOT â€” covers full screen, is the XR dom-overlay root â”€â”€ */
/* Everything the user needs to interact with in AR lives inside #xrOverlay */
#xrOverlay {
  position:fixed; inset:0; z-index:300;
  pointer-events:none;   /* children opt-in with pointer-events:all */
}

/* â”€â”€ HUD â”€â”€ */
#hud {
  position:absolute; bottom:0; left:0; right:0; padding:10px 12px 34px;
  display:flex; flex-direction:column; align-items:center; gap:8px;
  pointer-events:none;
}
#hudHint {
  font-size:11px; letter-spacing:.15em; text-transform:uppercase;
  color:rgba(255,255,255,.9); background:rgba(0,0,0,.72);
  backdrop-filter:blur(12px); -webkit-backdrop-filter:blur(12px);
  padding:8px 16px; border-radius:100px; border:1px solid rgba(255,255,255,.12);
  max-width:93vw; text-align:center; line-height:1.6;
}
#statusBar {
  display:none; font-size:9px; letter-spacing:.1em; font-family:var(--mono);
  color:rgba(255,255,255,.7); background:rgba(0,0,0,.65);
  backdrop-filter:blur(8px); -webkit-backdrop-filter:blur(8px);
  padding:6px 14px; border-radius:8px; border:1px solid rgba(255,255,255,.08);
  white-space:pre; line-height:1.7; text-align:left; max-width:96vw;
  pointer-events:none;
}
.slider-row { display:flex; align-items:center; gap:7px; pointer-events:all; }
.sl-lbl { font-size:10px; letter-spacing:.13em; color:rgba(255,255,255,.42); min-width:44px; }
input[type=range] { -webkit-appearance:none; width:96px; height:2px; background:rgba(255,255,255,.18); border-radius:1px; outline:none; }
input[type=range]::-webkit-slider-thumb { -webkit-appearance:none; width:16px; height:16px; border-radius:50%; background:var(--accent); cursor:pointer; }
.btn-row { display:flex; gap:6px; pointer-events:all; flex-wrap:wrap; justify-content:center; }
.hud-btn {
  background:rgba(8,8,16,.82); backdrop-filter:blur(12px); -webkit-backdrop-filter:blur(12px);
  border:1px solid rgba(255,255,255,.14); color:#fff;
  padding:9px 13px; font-family:var(--mono); font-size:10px;
  letter-spacing:.11em; text-transform:uppercase; cursor:pointer;
  border-radius:2px; transition:background .15s, border-color .15s, color .15s;
}
.hud-btn:active { transform:scale(.95); }
.hud-btn:hover  { background:rgba(232,79,43,.18); border-color:var(--accent); }
.hud-btn.g  { background:rgba(43,232,122,.16); border-color:var(--green); color:var(--green); }
.hud-btn.b  { background:rgba(77,166,255,.16); border-color:var(--blue); color:var(--blue); }
.hud-btn.y  { background:rgba(240,208,96,.16); border-color:var(--yellow); color:var(--yellow); }
.hud-btn.r  { border-color:rgba(232,79,43,.4); }

/* Badges â€” inside xrOverlay */
#scanRing { display:none; position:absolute; left:50%; top:40%; transform:translate(-50%,-50%); pointer-events:none; }
#scanRing svg { animation:pulse 1.4s ease-in-out infinite; }
@keyframes pulse { 0%,100%{opacity:.3;transform:scale(.88)} 50%{opacity:1;transform:scale(1.05)} }

#snapReticle { display:none; position:absolute; left:50%; top:40%; transform:translate(-50%,-50%); pointer-events:none; }
#snapIndicator {
  display:none; position:absolute; top:18px; left:50%; transform:translateX(-50%);
  font-size:10px; letter-spacing:.22em; text-transform:uppercase; white-space:nowrap;
  padding:5px 16px; border-radius:100px;
  border:1px solid var(--green); color:var(--green); background:rgba(43,232,122,.12);
}
#cornerBadge {
  display:none; position:absolute; top:18px; left:50%; transform:translateX(-50%);
  font-size:11px; letter-spacing:.2em; text-transform:uppercase; white-space:nowrap;
  padding:6px 16px; border-radius:100px;
  background:rgba(77,166,255,.12); border:1px solid var(--blue); color:var(--blue);
}
#planeBadge {
  display:none; position:absolute; top:18px; right:14px;
  font-size:10px; letter-spacing:.18em; text-transform:uppercase; white-space:nowrap;
  padding:5px 12px; border-radius:100px;
  background:rgba(43,232,122,.1); border:1px solid var(--green); color:var(--green);
}
#driftBadge {
  display:none; position:absolute; top:52px; right:14px;
  font-size:10px; letter-spacing:.14em; text-transform:uppercase; white-space:nowrap;
  padding:4px 10px; border-radius:100px;
  background:rgba(240,208,96,.08); border:1px solid var(--yellow); color:var(--yellow);
}
#toast {
  display:none; position:absolute; top:54px; left:50%; transform:translateX(-50%);
  background:rgba(0,0,0,.86); backdrop-filter:blur(10px); -webkit-backdrop-filter:blur(10px);
  border:1px solid rgba(255,255,255,.1); padding:9px 22px;
  font-size:11px; letter-spacing:.11em; color:#fff; border-radius:100px; white-space:nowrap;
}

/* Measurement label floating in 3D space (projected to screen) */
#measureLabel {
  display:none; position:absolute; pointer-events:none;
  background:rgba(240,208,96,.92); color:#080810;
  font-size:11px; font-weight:700; letter-spacing:.12em;
  padding:5px 13px; border-radius:100px;
  transform:translate(-50%,-50%);
  box-shadow:0 2px 12px rgba(0,0,0,.4);
}

/* â”€â”€ PICK OVERLAY â”€â”€ */
#pickOverlay {
  display:none; position:absolute; inset:0;
  background:rgba(4,5,15,.97);
  flex-direction:column; pointer-events:all; overflow:hidden;
}
#pickOverlay.show { display:flex; }

/* Header bar */
#pickHeader {
  display:flex; align-items:center; justify-content:space-between;
  padding:12px 16px 10px; flex-shrink:0;
  border-bottom:1px solid rgba(255,255,255,.07);
}
#pickTitle {
  font-size:10px; letter-spacing:.3em; text-transform:uppercase;
  color:var(--accent); margin:0;
}
#pickModeToggle {
  display:flex; gap:0; border:1px solid rgba(255,255,255,.15); border-radius:3px; overflow:hidden;
}
.mode-tab {
  background:none; border:none; color:rgba(255,255,255,.4);
  font-family:var(--mono); font-size:9px; letter-spacing:.2em; text-transform:uppercase;
  padding:6px 12px; cursor:pointer; transition:background .15s, color .15s;
}
.mode-tab.active { background:rgba(255,255,255,.1); color:var(--paper); }

/* Zoom viewport â€” fills all available space */
#pickViewport {
  flex:1; overflow:hidden; position:relative; cursor:crosshair;
  touch-action:none; background:#08080f;
}
#pickCanvas {
  position:absolute; top:0; left:0;
  transform-origin:0 0;
  image-rendering:pixelated;
}
/* Zoom controls */
#pickZoomCtrls {
  position:absolute; bottom:10px; right:10px;
  display:flex; flex-direction:column; gap:4px; z-index:20;
}
.zoom-btn {
  width:32px; height:32px; border-radius:4px;
  background:rgba(4,5,15,.88); border:1px solid rgba(255,255,255,.18);
  color:var(--paper); font-size:18px; line-height:1; cursor:pointer;
  display:flex; align-items:center; justify-content:center;
}
.zoom-btn:active { background:rgba(255,255,255,.12); }
#pickZoomLabel {
  position:absolute; bottom:10px; left:10px; z-index:20;
  font-size:9px; letter-spacing:.15em; color:rgba(255,255,255,.3);
}

/* Ruler mode canvas tint */
#pickViewport.ruler-active { cursor:crosshair; }
#pickViewport.ruler-active #pickCanvas { filter:brightness(.85) sepia(.15); }

/* Footer */
#pickFooter {
  flex-shrink:0; padding:10px 14px 14px;
  border-top:1px solid rgba(255,255,255,.07);
  display:flex; flex-direction:column; gap:8px;
}

/* Anchor-pick mode status */
#pickAnchorStatus {
  display:flex; align-items:center; justify-content:space-between; gap:8px;
}
#pickInfo { font-size:10px; letter-spacing:.14em; color:var(--blue); }
#pickSub  { font-size:10px; color:rgba(232,228,219,.4); letter-spacing:.08em; }

/* Ruler mode controls */
#rulerControls {
  display:none; align-items:center; gap:8px; flex-wrap:wrap;
}
#rulerControls.show { display:flex; }
#rulerStatus {
  font-size:10px; letter-spacing:.1em; flex:1;
  color:rgba(240,208,96,.75);
}
#rulerDistInput {
  background:rgba(0,0,0,.6); border:1px solid rgba(240,208,96,.4); color:var(--yellow);
  font-family:var(--mono); font-size:12px; padding:6px 10px; width:80px;
  border-radius:2px; outline:none; text-align:center;
}
#rulerDistInput::placeholder { color:rgba(240,208,96,.25); }
#rulerConfirmBtn {
  background:rgba(240,208,96,.14); border:1px solid var(--yellow); color:var(--yellow);
  padding:7px 13px; font-family:var(--mono); font-size:9px; letter-spacing:.18em;
  text-transform:uppercase; cursor:pointer; border-radius:2px; white-space:nowrap;
}
#rulerConfirmBtn:disabled { opacity:.3; cursor:not-allowed; }

/* Footer action row */
.pick-btns {
  display:flex; gap:7px; flex-wrap:wrap;
}
.pick-btn {
  background:rgba(255,255,255,.05); border:1px solid rgba(255,255,255,.15); color:var(--paper);
  padding:9px 14px; font-family:var(--mono); font-size:9px; letter-spacing:.18em;
  text-transform:uppercase; cursor:pointer; border-radius:3px;
  transition:background .15s, border-color .15s;
}
.pick-btn:hover { background:rgba(255,255,255,.1); border-color:rgba(255,255,255,.3); }
.pick-btn.confirm {
  background:var(--accent); border-color:var(--accent); color:#fff; margin-left:auto;
}
.pick-btn.confirm:disabled { background:rgba(255,255,255,.08); border-color:rgba(255,255,255,.1); color:rgba(255,255,255,.3); cursor:not-allowed; }
.pick-btn.ruler-active { background:rgba(240,208,96,.14); border-color:var(--yellow); color:var(--yellow); }


/* â”€â”€ GPS / COMPASS HUD PANEL â”€â”€ */
#gpsPanel {
  position:absolute; top:14px; left:14px;
  display:none; flex-direction:column; gap:5px;
  pointer-events:all; z-index:10;
}
#gpsPanel.show { display:flex; }
#gpsBadge {
  display:flex; align-items:center; gap:7px;
  background:rgba(4,5,15,.88); backdrop-filter:blur(12px);
  border:1px solid rgba(255,255,255,.1); border-radius:6px;
  padding:7px 11px; min-width:180px;
}
#gpsAccDot {
  width:8px; height:8px; border-radius:50%; flex-shrink:0;
  background:var(--green); box-shadow:0 0 6px var(--green);
  transition:background .4s, box-shadow .4s;
}
#gpsAccDot.yellow { background:var(--yellow); box-shadow:0 0 6px var(--yellow); }
#gpsAccDot.red    { background:var(--accent);  box-shadow:0 0 6px var(--accent); }
#gpsText { font-size:9px; letter-spacing:.1em; line-height:1.7; color:rgba(232,228,219,.6); }
#gpsText strong { color:var(--paper); letter-spacing:.04em; display:block; }
#compassBadge {
  display:flex; align-items:center; gap:8px;
  background:rgba(4,5,15,.88); backdrop-filter:blur(12px);
  border:1px solid rgba(255,255,255,.1); border-radius:6px;
  padding:6px 11px;
}
#compassRose { width:28px; height:28px; flex-shrink:0; }
#compassRose svg { display:block; transition:transform .25s ease; }
#compassText { font-size:9px; letter-spacing:.1em; color:rgba(232,228,219,.6); line-height:1.7; }
#compassText strong { color:var(--paper); display:block; }
#gpsDriftBadge {
  display:none; align-items:center; gap:6px;
  background:rgba(4,5,15,.88); backdrop-filter:blur(12px);
  border-radius:6px; padding:6px 11px; border:1px solid rgba(255,255,255,.1);
  font-size:9px; letter-spacing:.11em; line-height:1.6; color:var(--paper);
}
#gpsDriftBadge.show { display:flex; }
#gpsDriftBadge.ok   { border-color:rgba(43,232,122,.4); color:var(--green); }
#gpsDriftBadge.warn { border-color:rgba(240,208,96,.4); color:var(--yellow); }
#gpsDriftBadge.bad  { border-color:rgba(232,79,43,.5);  color:var(--accent); }
.wp-label {
  position:absolute; pointer-events:none; white-space:nowrap;
  background:rgba(77,166,255,.92); color:#04050f;
  font-size:9px; font-weight:700; letter-spacing:.1em;
  padding:3px 9px; border-radius:100px;
  transform:translate(-50%,-140%);
  box-shadow:0 2px 8px rgba(0,0,0,.5);
}
#gpsMap {
  display:none; position:absolute; bottom:160px; right:14px;
  width:140px; height:140px;
  background:rgba(4,5,15,.92); backdrop-filter:blur(10px);
  border:1px solid rgba(77,166,255,.25); border-radius:6px;
  overflow:hidden; pointer-events:none;
}
#gpsMap.show { display:block; }
#gpsMapCanvas { width:140px; height:140px; display:block; }
#gpsMapLabel {
  position:absolute; bottom:4px; left:0; right:0; text-align:center;
  font-size:8px; letter-spacing:.15em; color:rgba(77,166,255,.45); text-transform:uppercase;
}
#gpsBtns { display:none; }
#gpsBtns.show { display:flex; }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   STEP WIZARD
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* Progress bar â€” thin strip at very top of AR screen */
#stepBar {
  display:none; position:absolute; top:0; left:0; right:0; z-index:200;
  height:3px; background:rgba(255,255,255,.08);
  pointer-events:none;
}
#stepBarFill {
  height:100%; background:var(--accent);
  transition:width .5s cubic-bezier(.4,0,.2,1);
}

/* Full-screen step card overlay */
#stepCard {
  display:none; position:absolute; inset:0; z-index:180;
  background:rgba(4,5,15,.96);
  flex-direction:column; align-items:center; justify-content:center;
  padding:32px 28px; pointer-events:all;
  animation:cardIn .35s cubic-bezier(.4,0,.2,1);
}
#stepCard.show { display:flex; }
@keyframes cardIn {
  from { opacity:0; transform:translateY(18px); }
  to   { opacity:1; transform:translateY(0); }
}

/* Step pill */
.sc-step {
  font-size:9px; letter-spacing:.35em; text-transform:uppercase;
  color:var(--accent); background:rgba(232,79,43,.12);
  border:1px solid rgba(232,79,43,.25); border-radius:100px;
  padding:4px 14px; margin-bottom:20px;
}

/* Icon area */
.sc-icon {
  width:80px; height:80px; border-radius:50%;
  background:rgba(255,255,255,.04); border:1px solid rgba(255,255,255,.08);
  display:flex; align-items:center; justify-content:center;
  font-size:34px; margin-bottom:22px; position:relative;
}
/* Animated ring on icon */
.sc-icon::before {
  content:''; position:absolute; inset:-6px; border-radius:50%;
  border:1px solid rgba(232,79,43,.2);
  animation:iconPulse 2.5s ease-in-out infinite;
}
@keyframes iconPulse {
  0%,100%{ transform:scale(1);   opacity:.4; }
  50%    { transform:scale(1.08); opacity:.9; }
}

.sc-title {
  font-family:var(--display); font-size:24px; font-weight:800;
  letter-spacing:-.01em; color:var(--paper);
  text-align:center; margin-bottom:8px; line-height:1.2;
}
.sc-sub {
  font-size:12px; letter-spacing:.06em; line-height:1.7;
  color:rgba(232,228,219,.45); text-align:center;
  max-width:300px; margin-bottom:28px;
}

/* Live status row inside card (GPS signal etc.) */
.sc-status {
  display:flex; align-items:center; gap:10px;
  background:rgba(255,255,255,.04); border:1px solid rgba(255,255,255,.08);
  border-radius:8px; padding:10px 18px; margin-bottom:24px;
  min-width:240px; justify-content:center;
}
.sc-dot {
  width:8px; height:8px; border-radius:50%; flex-shrink:0;
  background:var(--accent); box-shadow:0 0 6px var(--accent);
  transition:background .3s, box-shadow .3s;
}
.sc-dot.yellow{ background:var(--yellow); box-shadow:0 0 6px var(--yellow); }
.sc-dot.green { background:var(--green);  box-shadow:0 0 6px var(--green); }
.sc-status-text { font-size:10px; letter-spacing:.1em; color:rgba(232,228,219,.6); }
.sc-status-text strong { color:var(--paper); display:block; font-size:11px; }

/* Primary CTA button */
.sc-btn {
  background:var(--accent); color:#fff; border:none;
  font-family:var(--mono); font-size:11px; letter-spacing:.22em;
  text-transform:uppercase; padding:14px 32px; border-radius:3px;
  cursor:pointer; transition:background .15s, transform .1s;
  min-width:200px; text-align:center;
}
.sc-btn:hover { background:#c83d1e; }
.sc-btn:active { transform:scale(.97); }
.sc-btn:disabled {
  background:rgba(255,255,255,.08); color:rgba(255,255,255,.25);
  cursor:not-allowed; transform:none;
}
.sc-btn.secondary {
  background:transparent; border:1px solid rgba(255,255,255,.2);
  color:rgba(255,255,255,.5); margin-top:10px;
  font-size:10px; letter-spacing:.18em; padding:10px 24px;
}

/* Step 3 anchor card: slides to bottom strip so AR is visible */
#stepCard.anchor-mode {
  justify-content:flex-end;
  padding-bottom:28px;
  background:linear-gradient(to top, rgba(4,5,15,.92) 0%, rgba(4,5,15,.0) 60%) !important;
}
#stepCard.anchor-mode .sc-icon,
#stepCard.anchor-mode .sc-title,
#stepCard.anchor-mode .sc-sub,
#stepCard.anchor-mode .sc-dots { display:none !important; }
#stepCard.anchor-mode .sc-step { margin-bottom:10px; }
#stepCard.anchor-mode .sc-status { margin-bottom:16px; }

  display:flex; gap:6px; margin-top:28px;
}
.sc-dot-s {
  width:6px; height:6px; border-radius:50%;
  background:rgba(255,255,255,.15); transition:background .3s;
}
.sc-dot-s.active { background:var(--accent); }
.sc-dot-s.done   { background:rgba(232,79,43,.4); }

</style>

<body>

<!-- LANDING (not inside xrOverlay â€” only shown before AR starts) -->
<div id="landing">
  <div class="landing-inner">
    <nav class="l-nav">
      <div class="l-logo"><span>AR</span>floor</div>
      <div class="l-badge">&#x25CF; WebXR Live</div>
    </nav>

    <h1 class="l-headline">
      Structure-locked
      <span class="line2">Floorplan AR.</span>
    </h1>
    <p class="l-sub">Anchored &middot; Drift-corrected &middot; Real-time</p>

    <div class="l-tags">
      <span class="l-tag hi">Hit-test</span>
      <span class="l-tag hi">Plane detection</span>
      <span class="l-tag hi">XR Anchors</span>
      <span class="l-tag">Scale ruler</span>
      <span class="l-tag">Measurement</span>
      <span class="l-tag">PDF overlay</span>
    </div>

    <div class="drop-zone" id="dropZone">
      <span class="drop-icon">&#x1F4C4;</span>
      <p class="drop-label">Drop floorplan PDF or tap to browse</p>
      <p class="drop-sub">Plane wireframes &middot; snap to edges &middot; drift-corrected anchors</p>
      <input type="file" id="fileInput" accept=".pdf,application/pdf">
      <canvas id="pdfThumb"></canvas>
      <div id="pageNav">
        <button class="pg-btn" id="prevPg">&#8249;</button>
        <span id="pgInfo">1 / 1</span>
        <button class="pg-btn" id="nextPg">&#8250;</button>
      </div>
    </div>
    <div id="errMsg"></div>
    <button id="launchBtn">Launch AR &rarr;</button>
    <p class="note">
      Scan ground &rarr; wireframes on detected surfaces &middot; Tap Anchor &rarr; walk to each column<br>
      (snaps to column edges) &rarr; set scale &rarr; pick columns on PDF &rarr; plan binds live
    </p>
  </div>
</div>

<!-- AR SCREEN -->
<div id="arScreen">
  <canvas id="arCanvas"></canvas>

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       #xrOverlay is the dom-overlay root for WebXR.
       EVERYTHING the user sees/taps in AR must live here.
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <div id="xrOverlay">

    <!-- Step progress bar (always visible once AR starts) -->
  <div id="stepBar"><div id="stepBarFill" style="width:0%"></div></div>

  <!-- Full-screen step cards -->
  <div id="stepCard" class="show">
    <div class="sc-step" id="scPill">Step 1 of 6</div>
    <div class="sc-icon" id="scIcon">ğŸ“¡</div>
    <h2 class="sc-title" id="scTitle">Activate Sensors</h2>
    <p class="sc-sub" id="scSub">GPS and compass must be active before starting. Move to open sky for best accuracy.</p>
    <div class="sc-status" id="scStatus">
      <div class="sc-dot" id="scDot"></div>
      <div class="sc-status-text"><strong id="scStatusMain">Waiting for GPSâ€¦</strong><span id="scStatusSub">accuracy: â€”</span></div>
    </div>
    <button class="sc-btn" id="scBtn" disabled>Continue â†’</button>
    <button class="sc-btn secondary" id="scSecondary" style="display:none"></button>
    <!-- Anchor-mode action row (only visible in step 3 strip) -->
    <div id="scAnchorBtns" style="display:none;gap:10px;margin-top:10px;">
      <button class="sc-btn secondary" id="scAnchorUndo" style="margin-top:0;">â†¶ Undo</button>
      <button class="sc-btn secondary" id="scAnchorRestart" style="margin-top:0;">â†º Restart</button>
    </div>
    <div class="sc-dots" id="scDots">
      <div class="sc-dot-s active" data-s="0"></div>
      <div class="sc-dot-s" data-s="1"></div>
      <div class="sc-dot-s" data-s="2"></div>
      <div class="sc-dot-s" data-s="3"></div>
      <div class="sc-dot-s" data-s="4"></div>
      <div class="sc-dot-s" data-s="5"></div>
    </div>
  </div>

  <!-- â”€â”€ GPS / COMPASS PANEL (top-left) â”€â”€ -->
    <div id="gpsPanel">
      <div id="gpsBadge">
        <div id="gpsAccDot"></div>
        <div id="gpsText">
          <strong id="gpsCoordsText">Acquiring GPSâ€¦</strong>
          <span id="gpsAccText">accuracy: â€”</span>
        </div>
      </div>
      <div id="compassBadge">
        <div id="compassRose">
          <svg width="28" height="28" viewBox="0 0 28 28" id="compassSvg">
            <circle cx="14" cy="14" r="13" stroke="rgba(255,255,255,.12)" stroke-width="1" fill="none"/>
            <!-- N pointer red, S pointer white -->
            <polygon points="14,3 11,14 14,12 17,14" fill="#e84f2b"/>
            <polygon points="14,25 11,14 14,16 17,14" fill="rgba(255,255,255,.4)"/>
            <circle cx="14" cy="14" r="2" fill="rgba(255,255,255,.6)"/>
          </svg>
        </div>
        <div id="compassText">
          <strong id="compassHeadingText">â€”Â°</strong>
          <span id="compassDirText">compass</span>
        </div>
      </div>
      <div id="gpsDriftBadge"></div>
    </div>

    <!-- GPS minimap -->
    <div id="gpsMap">
      <canvas id="gpsMapCanvas" width="140" height="140"></canvas>
      <div id="gpsMapLabel">GPS Waypoints</div>
    </div>

    <!-- Waypoint label container -->
    <div id="wpLabels" style="position:absolute;inset:0;pointer-events:none;"></div>

    <!-- Scan / snap reticles -->
    <div id="scanRing">
      <svg width="180" height="180" viewBox="0 0 180 180" fill="none">
        <ellipse cx="90" cy="90" rx="78" ry="34" stroke="#e84f2b" stroke-width="1.5" stroke-dasharray="6 4"/>
        <ellipse cx="90" cy="90" rx="50" ry="22" stroke="rgba(232,79,43,.3)" stroke-width="1"/>
        <line x1="68" y1="90" x2="112" y2="90" stroke="#e84f2b" stroke-width="1.2"/>
        <line x1="90" y1="68" x2="90" y2="112" stroke="#e84f2b" stroke-width="1.2"/>
      </svg>
    </div>
    <div id="snapReticle">
      <svg width="64" height="64" viewBox="0 0 64 64" fill="none">
        <circle cx="32" cy="32" r="26" stroke="#4da6ff" stroke-width="1.5" stroke-dasharray="5 3" id="snapCircle"/>
        <line x1="32" y1="14" x2="32" y2="50" stroke="#4da6ff" stroke-width="1" id="snapV"/>
        <line x1="14" y1="32" x2="50" y2="32" stroke="#4da6ff" stroke-width="1" id="snapH"/>
        <circle cx="32" cy="32" r="4" fill="#4da6ff" id="snapDot"/>
      </svg>
    </div>

    <!-- Status badges -->
    <div id="snapIndicator">&#x25C6; Snapped to edge</div>
    <div id="cornerBadge"></div>
    <div id="planeBadge">&#x2713; Surface Detected</div>
    <div id="driftBadge">&#x21BA; Anchors updated</div>
    <div id="toast"></div>
    <div id="measureLabel"></div>

    <!-- â”€â”€ PDF PICK OVERLAY â”€â”€ -->
    <div id="pickOverlay">

      <!-- Header -->
      <div id="pickHeader">
        <p id="pickTitle">PICK COLUMNS ON THE PLAN</p>
        <div id="pickModeToggle">
          <button class="mode-tab active" id="tabAnchor">Anchor</button>
          <button class="mode-tab" id="tabRuler">Scale</button>
        </div>
      </div>

      <!-- Zoomable canvas viewport -->
      <div id="pickViewport">
        <canvas id="pickCanvas"></canvas>
        <div id="pickZoomCtrls">
          <button class="zoom-btn" id="zoomIn">+</button>
          <button class="zoom-btn" id="zoomOut">âˆ’</button>
          <button class="zoom-btn" id="zoomReset" style="font-size:11px;letter-spacing:0;">âŠ¡</button>
        </div>
        <div id="pickZoomLabel">100%</div>
      </div>

      <!-- Footer -->
      <div id="pickFooter">

        <!-- Anchor-pick status (shown in Anchor tab) -->
        <div id="pickAnchorStatus">
          <span id="pickInfo">0 picked</span>
          <span id="pickSub">Tap each column in order</span>
        </div>

        <!-- Ruler controls (shown in Scale tab) -->
        <div id="rulerControls">
          <span id="rulerStatus">Drag a line across a known dimension</span>
          <input type="number" id="rulerDistInput" placeholder="metres" min="0.01" step="0.01">
          <button id="rulerConfirmBtn" disabled>Set</button>
        </div>

        <!-- Action buttons -->
        <div class="pick-btns">
          <button class="pick-btn" id="pickUndoBtn">â†¶ Undo</button>
          <button class="pick-btn" id="pickClearBtn">âœ• Clear All</button>
          <button class="pick-btn" id="pickCancelBtn">Cancel</button>
          <button class="pick-btn confirm" id="pickConfirmBtn" disabled>Bind Plan â†’</button>
        </div>

      </div>
    </div>

    <!-- â”€â”€ HUD (inside xrOverlay) â”€â”€ -->
    <div id="hud">
      <div id="hudHint">Point camera at the ground</div>
      <div id="statusBar"></div>
      <div class="slider-row">
        <span class="sl-lbl">Opacity</span>
        <input type="range" id="opacitySlider" min="20" max="100" value="82">
        <span class="sl-lbl" id="opacityVal">82%</span>
      </div>
      <div class="btn-row" id="normalBtns">
        <button class="hud-btn" id="alignBtn">&#x1F9ED; Align N</button>
        <button class="hud-btn" id="lockBtn">&#x1F513; Unlock</button>
        <button class="hud-btn b" id="traceBtn">&#x25CE; Anchor</button>
        <button class="hud-btn y" id="measureBtn">&#x1F4CF; Measure</button>
        <button class="hud-btn b" id="dropPinBtn" style="display:none;">&#x1F4CD; Pin</button>
        <button class="hud-btn" id="gpsToggleBtn">&#x1F6F0; GPS</button>
        <button class="hud-btn" id="resetBtn">Reset</button>
        <button class="hud-btn r" id="exitBtn">&#x2715; Exit</button>
      </div>
      <div class="btn-row" id="measureBtns" style="display:none;">
        <button class="hud-btn" id="measureClearBtn">&#x21B6; Clear</button>
        <button class="hud-btn r" id="measureExitBtn">&#x2715; Done</button>
      </div>
      <div class="btn-row" id="traceBtns" style="display:none;">
        <button class="hud-btn" id="traceUndoBtn">&#x21B6; Undo</button>
        <button class="hud-btn g" id="traceDoneBtn">&#x2713; Done</button>
        <button class="hud-btn r" id="traceCancelBtn">&#x2715; Cancel</button>
      </div>
    </div>

  </div><!-- end #xrOverlay -->
</div><!-- end #arScreen -->

<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
(function () {
'use strict';

pdfjsLib.GlobalWorkerOptions.workerSrc =
  'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   BOWYER-WATSON DELAUNAY (XZ)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function delaunay(pts) {
  if (pts.length < 3) return [];
  var minX=Infinity, minZ=Infinity, maxX=-Infinity, maxZ=-Infinity;
  pts.forEach(function(p){ minX=Math.min(minX,p.x); minZ=Math.min(minZ,p.z); maxX=Math.max(maxX,p.x); maxZ=Math.max(maxZ,p.z); });
  var span = Math.max(maxX-minX, maxZ-minZ)*10+1;
  var cx=(minX+maxX)/2, cz=(minZ+maxZ)/2;
  var all=pts.slice(), s0=all.length;
  all.push({x:cx-span*2,z:cz-span},{x:cx,z:cz+span*2},{x:cx+span*2,z:cz-span});
  var tris=[{a:s0,b:s0+1,c:s0+2}];

  function circ(t){
    var ax=all[t.a].x,az=all[t.a].z,bx=all[t.b].x,bz=all[t.b].z,cx2=all[t.c].x,cz2=all[t.c].z;
    var D=2*(ax*(bz-cz2)+bx*(cz2-az)+cx2*(az-bz));
    if(Math.abs(D)<1e-10) return {x:0,z:0,r2:1e18};
    var ux=((ax*ax+az*az)*(bz-cz2)+(bx*bx+bz*bz)*(cz2-az)+(cx2*cx2+cz2*cz2)*(az-bz))/D;
    var uz=((ax*ax+az*az)*(cx2-bx)+(bx*bx+bz*bz)*(ax-cx2)+(cx2*cx2+cz2*cz2)*(bx-ax))/D;
    var dx=ax-ux,dz=az-uz; return {x:ux,z:uz,r2:dx*dx+dz*dz};
  }

  for(var i=0;i<pts.length;i++){
    var p=all[i], bad=[], j;
    for(j=tris.length-1;j>=0;j--){var c2=circ(tris[j]),dx=p.x-c2.x,dz=p.z-c2.z; if(dx*dx+dz*dz<c2.r2){bad.push(tris[j]);tris.splice(j,1);}}
    var edges=[];
    bad.forEach(function(t){[[t.a,t.b],[t.b,t.c],[t.c,t.a]].forEach(function(e){
      if(!bad.some(function(t2){return t2!==t&&(t2.a===e[0]||t2.b===e[0]||t2.c===e[0])&&(t2.a===e[1]||t2.b===e[1]||t2.c===e[1]);}))edges.push(e);
    });});
    edges.forEach(function(e){tris.push({a:e[0],b:e[1],c:i});});
  }
  return tris.filter(function(t){return t.a<s0&&t.b<s0&&t.c<s0;});
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   STATE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
var pdfDoc=null, currentPage=1, pdfCanvas=null;
var xfOpacity=0.82, xfRotY=0.0, xfScaleM=1.0, xfLocked=true;
var traceMode=false, MAX_CORNERS=10;
var corners=[];   // {worldPos:{x,y,z}, anchor:XRAnchor|null}
var uvPicks=[];   // {u,v}  â€” plan UV coords for each column
var boundMesh=null, solveCount=0;
var currentSnap=null;

/* â”€â”€ Rigid plan transform (Kabsch solver output) â”€â”€
   The plan is a single rigid body.  We never warp it.
   planOrigin: THREE.Vector3  â€” world position of plan centre
   planYaw:    number (rad)   â€” plan rotation around world-up
   planScale:  number (m/UV)  â€” uniform scale
   These are the ONLY things that change when we re-solve.         */
var planOrigin=new THREE.Vector3();
var planYaw=0;
var planScale=1;
var planBound=false;  // true once first Kabsch solve succeeds

/* â”€â”€ Heading fusion state â”€â”€
   We run a complementary filter:
     fusedHeading = Î±Â·compassRaw + (1-Î±)Â·(fusedHeading + gyroRateÂ·dt)
   Î±=0.02 â†’ gyro dominates short-term, compass corrects long-term drift */
var fusedHeading=null;    // degrees, 0=North
var lastGyroTime=null;
var gyroRate=0;           // deg/s from deviceorientation alpha delta
var lastAlpha=null;       // previous deviceorientation alpha
var COMPASS_ALPHA=0.02;   // complementary filter weight for compass
var headingLocked=false;  // true once we have a stable fused heading

/* XRâ†’North offset: captured at placement time.
   xrNorthOffset = fusedHeading at moment of placement.
   Plan yaw in XR = (desiredCompassHeading - xrNorthOffset) * Ï€/180
   So plan-top pointing North = yaw of -xrNorthOffset in XR space.  */
var xrNorthOffset=null;

/* GPS bearing calibration â€” two fixes = one bearing vector */
var gpsBearingFixes=[];   // [{lat,lng,ts}] â€” rolling buffer, last 6
var gpsBearingRef=null;   // {heading:deg, confidence:0-1} from GPS pairs

/* Plane re-snap throttle */
var reSnapFrameCounter=0;
var RESNAP_INTERVAL=45;   // frames between re-snap attempts
var RESNAP_THRESHOLD=0.15; // metres â€” max allowed silent correction

/* Per-constraint quality â€” fed to status panel */
var constraintQuality={
  xrAnchor:  0,   // 0-1
  compass:   0,
  gpsBearing:0,
  planeSnap: 0
};

/* Scale ruler */
var metersPerUV=null;    // set by ruler: metres / UV unit distance
var rulerMode=false;     // true while user is dragging ruler line on pickCanvas
var rulerP1=null, rulerP2=null;   // {x,y} in pickCanvas coords (normalised 0-1)
var rulerLine=null;      // SVG overlay line element

/* Measurement tool */
var measureMode=false;
var measurePt1=null, measurePt2=null;   // THREE.Vector3 world positions
var measureLine=null;    // THREE.Line in scene
var measureDots=[];      // sphere meshes

/* Three.js / XR */
var xrSession=null, xrRefSpace=null, xrHitTestSrc=null;
var renderer=null, scene=null, camera=null, reticle=null;
var planeGroup=null, planeMesh=null;
var wxrPlaced=false, wxrFloorFound=false;
var surfaceQuat=new THREE.Quaternion();
var floorPlane=new THREE.Plane(new THREE.Vector3(0,1,0),0);
var prevPinchDist=null, prevPinchAngle=null;

/* Wire visuals */
var wireLines=[], wireDots=[];
var planeWires=new Map();   // XRPlane -> THREE.Line (boundary loop)
var planesEnabled=false;    // true once we confirm frame.detectedPlanes works

var CORNER_COLORS=[0xe84f2b,0x2be87a,0x4da6ff,0xf0d060,0xe030f0,0x30e0f0,0xf09030,0xff88aa,0x88ffcc,0xccaaff];

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   WIZARD STATE MACHINE
   6 steps, each with its own card config and entry/exit hooks.
   currentStep: 0-5  (0=sensors, 1=place, 2=orient, 3=anchor, 4=pick, 5=bound)
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
var currentStep = -1;   /* -1 = not started (landing screen) */
var GPS_ACC_GATE = 15;  /* metres â€” required to pass step 0    */

var STEPS = [
  /* 0 â€” SENSORS */
  {
    pill:'Step 1 Â· Sensors',
    icon:'ğŸ“¡',
    title:'Activate Sensors',
    sub:'GPS and compass are required for True North alignment and drift correction. Move to open sky.',
    btnLabel:'Sensors Ready â†’',
    btnDisabled:true,
    hasStatus:true,
    hasSecondary:false,
    barPct:0
  },
  /* 1 â€” PLACE */
  {
    pill:'Step 2 Â· Place',
    icon:'ğŸ“',
    title:'Place the Plan',
    sub:'Point your camera at the ground. When the reticle appears, tap to place the plan. It will auto-align to True North.',
    btnLabel:'Skip to Orient â†’',
    btnDisabled:false,
    hasStatus:false,
    hasSecondary:false,
    barPct:17
  },
  /* 2 â€” ORIENT */
  {
    pill:'Step 3 Â· Orient',
    icon:'ğŸ”„',
    title:'Orient the Plan',
    sub:'Pinch to scale Â· Two-finger rotate Â· Single-finger drag (unlock first). When the plan matches the site, lock it.',
    btnLabel:'Plan is Positioned â†’',
    btnDisabled:false,
    hasStatus:false,
    hasSecondary:false,
    barPct:34
  },
  /* 3 â€” ANCHOR */
  {
    pill:'Step 4 Â· Anchor',
    icon:'âŠ™',
    title:'Anchor to Columns',
    sub:'Walk to each physical column base and tap the ground. GPS + structure snap captured per anchor. Minimum 3.',
    btnLabel:'Done â€” Pick on Plan â†’',
    btnDisabled:true,
    hasStatus:true,
    hasSecondary:false,
    barPct:50
  },
  /* 4 â€” PICK */
  {
    pill:'Step 5 Â· Pick',
    icon:'ğŸ¯',
    title:'Identify on Plan',
    sub:'Hold on each column on the PDF in the same order you anchored them. Use Scale tab to set a known dimension.',
    btnLabel:'Open Plan Picker â†’',
    btnDisabled:false,
    hasStatus:false,
    hasSecondary:false,
    barPct:68
  },
  /* 5 â€” BOUND */
  {
    pill:'Step 6 Â· Bound',
    icon:'âœ“',
    title:'Plan Locked',
    sub:'Rigid-body solve complete. Add more column anchors anytime to improve accuracy.',
    btnLabel:'Close',
    btnDisabled:false,
    hasStatus:true,
    hasSecondary:true,
    secondaryLabel:'+ Add More Anchors',
    barPct:100
  }
];

function goStep(n){
  currentStep = n;
  var s = STEPS[n];

  /* Update card content */
  el('scPill').textContent   = s.pill;
  el('scIcon').textContent   = s.icon;
  el('scTitle').textContent  = s.title;
  el('scSub').textContent    = s.sub;
  el('scBtn').textContent    = s.btnLabel;
  el('scBtn').disabled       = s.btnDisabled;
  el('scStatus').style.display = s.hasStatus ? 'flex' : 'none';

  var sec = el('scSecondary');
  if(s.hasSecondary){
    sec.style.display=''; sec.textContent=s.secondaryLabel||'';
  } else { sec.style.display='none'; }

  /* Progress bar */
  el('stepBar').style.display='block';
  el('stepBarFill').style.width = s.barPct + '%';

  /* Dot indicators */
  el('scDots').querySelectorAll('.sc-dot-s').forEach(function(d){
    var i = parseInt(d.dataset.s);
    d.className = 'sc-dot-s' + (i===n?' active':i<n?' done':'');
  });

  /* HUD visibility â€” hide during early wizard steps to reduce noise */
  var showHud = n >= 2;
  el('hud').style.display = showHud ? '' : 'none';

  /* Show card */
  el('stepCard').className = 'show' + (n===3?' anchor-mode':'');

  /* Step-specific setup */
  if(n===0) stepSensorsEnter();
  if(n===1) stepPlaceEnter();
  if(n===2) stepOrientEnter();
  if(n===3) stepAnchorEnter();
  if(n===4) stepPickEnter();
  if(n===5) stepBoundEnter();
}

function dismissCard(){
  el('stepCard').className = '';
}

/* â”€â”€ scBtn click routing â”€â”€
   Each card is an EXPLAINER that dismisses, then the step action happens.
   The card does NOT trigger the action â€” it just gets out of the way.      */
el('scBtn').addEventListener('click', function(){
  if(currentStep===0){
    /* Sensors gate â€” only enabled when GPS+compass ready. Dismiss â†’ show place card */
    goStep(1);
  } else if(currentStep===1){
    /* "Got it" â€” dismiss card, user now taps the ground themselves */
    dismissCard();
    el('hudHint').textContent='Point camera at ground \u2022 tap to place plan';
  } else if(currentStep===2){
    /* "Got it" â€” dismiss card, user adjusts freely then taps Lock themselves */
    dismissCard();
    el('hudHint').textContent='Pinch \u00b7 rotate \u00b7 drag to position \u2022 tap Lock when ready';
  } else if(currentStep===3){
    /* "Done" on anchor step â€” only reaches here if corners.length>=3 */
    if(corners.length>=3){
      /* Stop trace mode, show pick card */
      traceMode=false;
      hide('snapReticle'); hide('snapIndicator'); hide('cornerBadge');
      showBtns('normal');
      goStep(4);
    }
  } else if(currentStep===4){
    /* "Open Plan Picker" â€” dismiss card, open the PDF picker */
    dismissCard();
    openPickOverlay();
  } else if(currentStep===5){
    /* Close â€” dismiss bound card */
    dismissCard();
  }
});

/* â”€â”€ scSecondary click routing â”€â”€ */
el('scSecondary').addEventListener('click', function(){
  if(currentStep===5){
    dismissCard();
    enterTraceMode();
  }
});

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Step 0 â€” SENSORS
   Starts GPS immediately. Updates card live.
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function stepSensorsEnter(){
  el('scDot').className = 'sc-dot';
  el('scStatusMain').textContent = 'Starting GPSâ€¦';
  el('scStatusSub').textContent  = 'accuracy: â€”';
  startGPS();  /* always force-start at step 0 */
}

/* Called from onGpsFix â€” updates sensor card while on step 0 */
function updateSensorCard(){
  if(currentStep !== 0) return;
  var acc = gpsAcc;
  var ready = acc != null && acc <= GPS_ACC_GATE;
  var compassOk = compassHeading != null;

  /* Dot colour */
  var dotCls = acc==null?'':'  ' + (acc<=GPS_ACC_GATE?'green':acc<=30?'yellow':'');
  el('scDot').className = 'sc-dot' + dotCls.trimEnd();

  el('scStatusMain').textContent = gpsLat!=null
    ? (Math.abs(gpsLat).toFixed(5)+'Â° '+(gpsLat>=0?'N':'S')+'  '+Math.abs(gpsLng).toFixed(5)+'Â° '+(gpsLng>=0?'E':'W'))
    : 'Acquiring GPSâ€¦';

  var accStr = acc!=null ? 'Â±'+acc.toFixed(0)+'m' : 'â€”';
  var compassStr = compassOk ? ' Â· compass âœ“' : ' Â· compassâ€¦';
  el('scStatusSub').textContent = 'accuracy: ' + accStr + compassStr;

  /* Unlock continue when GPS â‰¤ gate AND compass active */
  el('scBtn').disabled = !(ready && compassOk);
  if(ready && compassOk) {
    el('scBtn').textContent = 'Sensors Ready â†’';
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Step 1 â€” PLACE
   Dismisses as soon as user taps floor.
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function stepPlaceEnter(){
  /* Card stays up â€” it dismisses automatically when wxrPlaced fires */
  el('hudHint').textContent = 'Point camera at the ground and tap to place';
}

/* Called from placement code when wxrPlaced becomes true */
function onPlanPlaced(){
  if(currentStep === 1){
    dismissCard();
    goStep(2);
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Step 2 â€” ORIENT
   User adjusts plan over site. Taps continue
   when satisfied (or lockBtn triggers it).
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function stepOrientEnter(){
  /* Card explains gestures. User taps "Got it", card dismisses.
     They adjust freely. When they tap Lock â†’ advances to step 3.
     Plan starts locked from placement â€” unlock button is right there. */
  el('hudHint').textContent='Pinch \u00b7 rotate \u00b7 drag to align plan over site';
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Step 3 â€” ANCHOR
   Walk to columns, tap. Card stays visible
   as a mini-HUD showing count.
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function stepAnchorEnter(){
  el('scStatus').style.display = 'flex';
  el('scDot').className = 'sc-dot yellow';
  el('scStatusMain').textContent = '0 columns anchored';
  el('scStatusSub').textContent  = 'hold reticle on column base to place';
  el('scBtn').disabled = true;
  el('scBtn').textContent = 'Done â€” Pick on Plan â†’';
  el('scAnchorBtns').style.display = 'flex';
  enterTraceMode();
}

el('scAnchorUndo').addEventListener('click', function(){
  undoCorner();
});
el('scAnchorRestart').addEventListener('click', function(){
  corners=[]; uvPicks=[]; clearWireVisuals();
  updateCornerBadge();
  el('hudHint').textContent='Walk to each column base \u2022 hold to anchor';
});

/* Called from updateCornerBadge when a new corner is added */
function updateAnchorCard(){
  if(currentStep !== 3) return;
  var n = corners.length;
  el('scDot').className = 'sc-dot' + (n>=3?' green':' yellow');
  el('scStatusMain').textContent = n + ' column' + (n!==1?'s':'') + ' anchored';
  el('scStatusSub').textContent  = n<3 ? (3-n)+' more needed' : 'tap Done or add more';
  el('scBtn').disabled = n < 3;
  if(n>=3) el('scBtn').textContent = 'Done â€” Pick on Plan â†’';
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Step 4 â€” PICK
   Card is a gateway â€” button opens picker.
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function stepPickEnter(){
  el('stepCard').classList.remove('anchor-mode');
  el('stepCard').style.background = '';
  el('scAnchorBtns').style.display = 'none';
}

/* Called when pickConfirmBtn fires buildBoundMesh */
function onPlanBound(){
  goStep(5);
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Step 5 â€” BOUND
   Live constraint quality shown in card.
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function stepBoundEnter(){
  el('stepCard').style.background = '';
  el('scDot').className = 'sc-dot green';
  el('scStatusMain').textContent = corners.length + ' column anchors';
  el('scStatusSub').textContent  = 'all sensors active Â· plan rigid-locked';
}

/* Update bound card quality live */
function updateBoundCard(){
  if(currentStep !== 5) return;
  var overall = (constraintQuality.xrAnchor*0.35 + constraintQuality.compass*0.30 +
                 constraintQuality.gpsBearing*0.15 + constraintQuality.planeSnap*0.20);
  el('scDot').className = 'sc-dot' + (overall>0.75?' green':overall>0.45?' yellow':'');
  el('scStatusSub').textContent = 'lock quality: ' + Math.round(overall*100) + '%  Â·  solve #' + solveCount;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Wizard-aware doReset
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function wizardReset(){
  doReset();
  currentStep = -1;
  el('stepBar').style.display = 'none';
  el('stepBarFill').style.width = '0%';
  el('stepCard').style.background = '';
  el('stepCard').classList.remove('anchor-mode');
  el('stepCard').className = '';  /* hide card */
}


function el(id){ return document.getElementById(id); }
function show(id,d){ el(id).style.display=d||'block'; }
function hide(id){ el(id).style.display='none'; }
function showBtns(which){
  el('normalBtns').style.display  = which==='normal'?'flex':'none';
  el('traceBtns').style.display   = which==='trace'?'flex':'none';
  el('measureBtns').style.display = which==='measure'?'flex':'none';
}
function showToast(msg,dur){
  el('toast').textContent=msg; show('toast');
  clearTimeout(showToast._t);
  showToast._t=setTimeout(function(){hide('toast');},dur||2600);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   PDF LOAD
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
el('dropZone').addEventListener('click',function(){el('fileInput').click();});
el('dropZone').addEventListener('dragover',function(e){e.preventDefault();el('dropZone').classList.add('over');});
el('dropZone').addEventListener('dragleave',function(){el('dropZone').classList.remove('over');});
el('dropZone').addEventListener('drop',function(e){e.preventDefault();el('dropZone').classList.remove('over');if(e.dataTransfer.files[0])loadFile(e.dataTransfer.files[0]);});
el('fileInput').addEventListener('change',function(){if(el('fileInput').files[0])loadFile(el('fileInput').files[0]);});

function loadFile(f){
  hide('errMsg'); el('launchBtn').classList.remove('show');
  var reader=new FileReader();
  reader.onload=function(ev){
    pdfjsLib.getDocument({data:ev.target.result}).promise
      .then(function(doc){pdfDoc=doc;currentPage=1;renderPage(1);el('pageNav').style.display=doc.numPages>1?'flex':'none';})
      .catch(function(e){showErr('PDF error: '+e.message);});
  };
  reader.onerror=function(){showErr('Read error.');};
  reader.readAsArrayBuffer(f);
}
function showErr(m){el('errMsg').textContent=m;show('errMsg');}
function renderPage(n){
  el('launchBtn').classList.remove('show');
  pdfDoc.getPage(n).then(function(page){
    var vp0=page.getViewport({scale:1});
    var sc=Math.min(8,8192/Math.max(vp0.width,vp0.height));
    var vp=page.getViewport({scale:sc});
    var hi=document.createElement('canvas');
    hi.width=Math.round(vp.width); hi.height=Math.round(vp.height);
    var thumb=el('pdfThumb'); thumb.width=Math.round(vp.width/4); thumb.height=Math.round(vp.height/4);
    thumb.style.display='block';
    var tCtx=thumb.getContext('2d'); tCtx.fillStyle='#12121f'; tCtx.fillRect(0,0,thumb.width,thumb.height);
    tCtx.fillStyle='#e84f2b'; tCtx.font='12px Courier New'; tCtx.textAlign='center';
    tCtx.fillText('Rendering '+hi.width+'\u00d7'+hi.height+'\u2026',thumb.width/2,thumb.height/2); tCtx.textAlign='left';
    page.render({canvasContext:hi.getContext('2d'),viewport:vp}).promise.then(function(){
      pdfCanvas=hi; tCtx.clearRect(0,0,thumb.width,thumb.height); tCtx.drawImage(hi,0,0,thumb.width,thumb.height);
      el('pgInfo').textContent=n+' / '+pdfDoc.numPages; el('launchBtn').classList.add('show');
    }).catch(function(e){showErr('Render error: '+e.message);});
  });
}
el('prevPg').addEventListener('click',function(){if(currentPage>1)renderPage(--currentPage);});
el('nextPg').addEventListener('click',function(){if(pdfDoc&&currentPage<pdfDoc.numPages)renderPage(++currentPage);});

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   LAUNCH
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
el('launchBtn').addEventListener('click',function(){
  if(!pdfCanvas)return;
  hide('landing'); show('arScreen');
  /* Start WebXR first, then immediately enter wizard step 0 */
  if(navigator.xr){
    navigator.xr.isSessionSupported('immersive-ar')
      .then(function(ok){ ok?startWebXR():noXR(); }).catch(noXR);
  } else { noXR(); }
  goStep(0);
});
function noXR(){el('hudHint').textContent='WebXR not supported \u2014 requires Android Chrome or compatible AR browser';}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   HUD CONTROLS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
el('opacitySlider').addEventListener('input',function(){
  xfOpacity=parseFloat(this.value)/100; el('opacityVal').textContent=this.value+'%';
  if(planeMesh)planeMesh.material.opacity=xfOpacity;
  if(boundMesh)boundMesh.material.opacity=xfOpacity;
});
el('rotCW') && el('rotCW').addEventListener && void 0; // removed
el('alignBtn').addEventListener('click',function(){
  if(!wxrPlaced){ el('hudHint').textContent='Place the plan first'; return; }
  var h=fusedHeading!=null?fusedHeading:compassHeading;
  if(h==null){ el('hudHint').textContent='Enable GPS for compass heading'; return; }
  /* Re-capture the offset so plan-top NOW aligns to North */
  xrNorthOffset=h;
  /* planYaw stays as-is; the heading constraint loop will now hold it
     at the current orientation as the "North" reference.
     For immediate snap: apply the inverse of heading delta from reference. */
  if(xrNorthOffset!=null){
    planYaw=xfRotY;
    if(planRigidGroup) planRigidGroup.rotation.y=planYaw;
  }
  el('hudHint').textContent='True North locked \u2014 '+Math.round(h)+'\u00b0 \u2714';
});
function applyFree(){if(planeGroup&&wxrPlaced)planeGroup.rotation.y=xfRotY;}

el('traceBtn').addEventListener('click',function(){
  if(!wxrFloorFound&&!wxrPlaced){el('hudHint').textContent='Point camera at the ground first';return;}
  enterTraceMode();
});
el('traceUndoBtn').addEventListener('click',undoCorner);
el('traceDoneBtn').addEventListener('click',function(){
  if(corners.length<3){el('hudHint').textContent='Need at least 3 column anchors';return;}
  showBtns('normal');
  hide('snapReticle'); hide('snapIndicator'); hide('cornerBadge');
  traceMode=false;
  if(currentStep===3){ goStep(4); }   /* show step-4 card as gateway to picker */
  else { openPickOverlay(); }          /* already past wizard, open directly */
});
el('traceCancelBtn').addEventListener('click',cancelTrace);
el('resetBtn').addEventListener('click', wizardReset);

/* lockBtn â€” on step 2 (orient), locking advances to step 3 */
el('lockBtn').addEventListener('click',function(){
  xfLocked=!xfLocked;
  this.textContent=xfLocked?'\uD83D\uDD12 Locked':'\uD83D\uDD13 Unlock';
  this.className=xfLocked?'hud-btn g':'hud-btn';
  el('hudHint').textContent=xfLocked?'Plan locked \u2714':'Drag to reposition';
  /* Step 2: first time user locks = advance to anchor step */
  if(xfLocked && currentStep===2){
    goStep(3);
  }
});
el('exitBtn').addEventListener('click',function(){
  if(xrSession){try{xrSession.end();}catch(e){}xrSession=null;}
  if(gpsEnabled)stopGPS();
  hide('arScreen'); show('landing','flex'); doReset();
});

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   ANCHOR MODE (column anchoring)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function enterTraceMode(){
  traceMode=true; corners=[];
  showBtns('trace'); hide('scanRing'); show('snapReticle'); show('cornerBadge');
  el('traceDoneBtn').style.opacity='0.4';
  updateCornerBadge();
  el('hudHint').textContent='Walk to each column base and tap to anchor';
  el('hudHint').textContent='Walk to column base â€¢ reticle snaps to structure';
}
function cancelTrace(){
  traceMode=false; corners=[]; clearWireVisuals();
  showBtns('normal'); hide('snapReticle'); hide('snapIndicator'); hide('cornerBadge');
  el('hudHint').textContent=wxrPlaced?'Plan placed \u2022 Tap Anchor to bind to columns':'Point camera at the ground';
}
function undoCorner(){
  if(corners.length===0)return;
  var c=corners.pop();
  if(c.anchor){try{c.anchor.delete();}catch(e){}}
  if(wireDots.length>0)scene.remove(wireDots.pop());
  if(wireLines.length>0)scene.remove(wireLines.pop());
  updateCornerBadge();
}
function updateCornerBadge(){
  var n=corners.length;
  el('cornerBadge').textContent=n+' column'+(n!==1?'s':'')+' anchored'+
    (n<3?' \u2014 need '+(3-n)+' more':' \u2014 tap Done when ready');
  el('traceDoneBtn').style.opacity=n>=3?'1':'0.4';
  updateAnchorCard();   /* keep wizard step-3 card in sync */
}
function addCornerVisual(pos,idx){
  var col=CORNER_COLORS[idx%CORNER_COLORS.length];
  var dot=new THREE.Mesh(new THREE.SphereGeometry(0.055,10,10),new THREE.MeshBasicMaterial({color:col}));
  dot.position.set(pos.x,pos.y+0.055,pos.z); scene.add(dot); wireDots.push(dot);
  if(corners.length>1){
    var prev=corners[corners.length-2].worldPos;
    var geo=new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(prev.x,prev.y+0.012,prev.z),
      new THREE.Vector3(pos.x,pos.y+0.012,pos.z)
    ]);
    var line=new THREE.Line(geo,new THREE.LineBasicMaterial({color:col}));
    scene.add(line); wireLines.push(line);
  }
}
function clearWireVisuals(){
  if(!scene)return;
  wireLines.forEach(function(l){scene.remove(l);}); wireLines=[];
  wireDots.forEach(function(d){scene.remove(d);}); wireDots=[];
}
function doReset(){
  traceMode=false; corners=[]; uvPicks=[];
  wxrPlaced=false; xfLocked=true; xfRotY=0; xfScaleM=1;
  currentSnap=null; solveCount=0;
  measureMode=false; measurePt1=null; measurePt2=null;
  metersPerUV=null; rulerP1=null; rulerP2=null;
  planBound=false; planYaw=0; planScale=1; planOrigin.set(0,0,0);
  fusedHeading=null; headingLocked=false; lastAlpha=null; lastGyroTime=null; xrNorthOffset=null;
  gpsBearingFixes=[]; gpsBearingRef=null; reSnapFrameCounter=0;
  constraintQuality={xrAnchor:0,compass:0,gpsBearing:0,planeSnap:0};
  clearMeasureVisuals(); hide('measureLabel');
  clearWaypoints();
  if(planRigidGroup&&scene){scene.remove(planRigidGroup);planRigidGroup=null;boundMesh=null;}
  else if(boundMesh&&scene){scene.remove(boundMesh);boundMesh=null;}
  if(planeGroup)planeGroup.visible=false;
  clearWireVisuals(); clearPlaneWires();
  showBtns('normal');
  show('scanRing'); hide('snapReticle'); hide('cornerBadge');
  hide('snapIndicator'); hide('driftBadge'); hide('planeBadge');
  hide('statusBar'); hide('pickOverlay');
  el('hudHint').textContent='Point camera at the ground';
  el('lockBtn').textContent='\uD83D\uDD13 Unlock'; el('lockBtn').className='hud-btn';
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   DETECTED PLANE WIREFRAMES
   Draws a green loop on floor planes,
   blue loop on wall planes.
   Works when plane-detection is enabled
   (Chrome flag or supported device).
   Falls back gracefully when unavailable.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function updatePlaneWireframes(frame, refSpace){
  if(!frame.detectedPlanes) return;
  planesEnabled=true;
  var seen=new Set();

  frame.detectedPlanes.forEach(function(plane){
    if(!plane.planeSpace||!plane.polygon||plane.polygon.length<3) return;
    try{
      var pp=frame.getPose(plane.planeSpace,refSpace);
      if(!pp) return;
      var pm=new THREE.Matrix4().fromArray(pp.transform.matrix);
      var isWall=plane.orientation==='vertical';
      var col=isWall?0x4da6ff:0x2be87a;
      var yOff=isWall?0:0.008;  // lift floor loops slightly off surface

      /* Build world-space points for boundary loop */
      var wpts=plane.polygon.map(function(v){
        return new THREE.Vector3(v.x,v.y,v.z).applyMatrix4(pm);
      });
      /* Close the loop */
      wpts.push(wpts[0].clone());
      var lifted=wpts.map(function(p){return new THREE.Vector3(p.x,p.y+yOff,p.z);});

      var existing=planeWires.get(plane);
      if(existing){
        /* Update positions in-place */
        var arr=new Float32Array(lifted.length*3);
        lifted.forEach(function(p,i){arr[i*3]=p.x;arr[i*3+1]=p.y;arr[i*3+2]=p.z;});
        existing.geometry.setAttribute('position',new THREE.BufferAttribute(arr,3));
        existing.geometry.attributes.position.needsUpdate=true;
        existing.geometry.computeBoundingSphere();
      } else {
        var geo=new THREE.BufferGeometry().setFromPoints(lifted);
        var mat=new THREE.LineBasicMaterial({color:col,transparent:true,opacity:isWall?0.75:0.55});
        var loop=new THREE.Line(geo,mat);
        scene.add(loop);
        planeWires.set(plane,loop);

        /* For floor planes also draw a grid inside the boundary so the
           surface area is visible when looking straight down           */
        if(!isWall){
          drawFloorGrid(pm, plane.polygon, col);
        }
      }
      seen.add(plane);
    }catch(e){}
  });

  /* Remove stale plane wires */
  planeWires.forEach(function(wire,key){
    if(typeof key!=='string' && !seen.has(key)){
      scene.remove(wire); planeWires.delete(key);
    }
  });
}

function drawFloorGrid(pm, polygon, col){
  var xs=polygon.map(function(v){return v.x;});
  var zs=polygon.map(function(v){return v.z;});
  var minX=Math.min.apply(null,xs),maxX=Math.max.apply(null,xs);
  var minZ=Math.min.apply(null,zs),maxZ=Math.max.apply(null,zs);
  var stepX=Math.max(0.25,(maxX-minX)/6);
  var stepZ=Math.max(0.25,(maxZ-minZ)/6);
  var pts=[];
  for(var x=minX;x<=maxX+0.01;x+=stepX){
    var p1=new THREE.Vector3(x,0.007,minZ).applyMatrix4(pm);
    var p2=new THREE.Vector3(x,0.007,maxZ).applyMatrix4(pm);
    pts.push(p1,p2);
  }
  for(var z=minZ;z<=maxZ+0.01;z+=stepZ){
    var p3=new THREE.Vector3(minX,0.007,z).applyMatrix4(pm);
    var p4=new THREE.Vector3(maxX,0.007,z).applyMatrix4(pm);
    pts.push(p3,p4);
  }
  if(pts.length<2)return;
  var geo=new THREE.BufferGeometry().setFromPoints(pts);
  var mat=new THREE.LineBasicMaterial({color:col,transparent:true,opacity:0.18});
  var segs=new THREE.LineSegments(geo,mat);
  scene.add(segs);
  /* Store with string key so it doesn't get reaped by the plane cleanup loop */
  planeWires.set('grid_'+Math.random().toString(36).slice(2),segs);
}

function clearPlaneWires(){
  if(!scene)return;
  planeWires.forEach(function(w){scene.remove(w);});
  planeWires.clear(); planesEnabled=false;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SNAP TO NEAREST PLANE VERTEX
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
var SNAP_DIST=0.35;
function snapToNearestPlaneVertex(pos,frame,refSpace){
  if(!frame.detectedPlanes) return null;
  var best=null, bestD2=SNAP_DIST*SNAP_DIST;
  frame.detectedPlanes.forEach(function(plane){
    if(!plane.planeSpace) return;
    try{
      var pp=frame.getPose(plane.planeSpace,refSpace);
      if(!pp) return;
      var pm=new THREE.Matrix4().fromArray(pp.transform.matrix);
      plane.polygon.forEach(function(v){
        var wp=new THREE.Vector3(v.x,v.y,v.z).applyMatrix4(pm);
        var dx=wp.x-pos.x, dz=wp.z-pos.z, d2=dx*dx+dz*dz;
        if(d2<bestD2){bestD2=d2;best=wp.clone();}
      });
    }catch(e){}
  });
  return best;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   PICK OVERLAY â€” zoom/pan viewport + tab switching
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* Viewport pan/zoom state */
var vpScale=1, vpOx=0, vpOy=0;
var vpDragStart=null, vpDragOrigin=null;
var vpPinchDist0=null, vpPinchScale0=null, vpPinchMid=null;
var pickMode='anchor'; /* 'anchor' | 'ruler' */

/* Ruler state (shared with ruler drawing on the canvas) */
var rulerP1=null, rulerP2=null;
var rulerMode=false;
var rulerLine=null;   // SVG line element inside viewport

function setPickTab(tab){
  pickMode=tab;
  el('tabAnchor').className='mode-tab'+(tab==='anchor'?' active':'');
  el('tabRuler').className='mode-tab'+(tab==='ruler'?' active':'');
  el('pickAnchorStatus').style.display=tab==='anchor'?'flex':'none';
  el('rulerControls').className=tab==='ruler'?'show':'';
  el('pickViewport').className=tab==='ruler'?'ruler-active':'';
  rulerMode=(tab==='ruler');
  el('pickCanvas').style.pointerEvents=tab==='ruler'?'none':'all';
  /* Show/hide ruler SVG overlay */
  var svg=el('pickViewport').querySelector('#rulerSvg');
  if(svg) svg.style.display=tab==='ruler'?'block':'none';
}

el('tabAnchor').addEventListener('click',function(){ setPickTab('anchor'); });
el('tabRuler').addEventListener('click',function(){ setPickTab('ruler'); });

/* Apply viewport transform */
function applyVP(){
  el('pickCanvas').style.transform='translate('+vpOx+'px,'+vpOy+'px) scale('+vpScale+')';
  el('pickZoomLabel').textContent=Math.round(vpScale*100)+'%';
  /* Reposition SVG overlay to match */
  var svg=el('pickViewport').querySelector('#rulerSvg');
  if(svg) svg.style.transform='translate('+vpOx+'px,'+vpOy+'px) scale('+vpScale+')';
  /* Reposition pdots */
  el('pickViewport').querySelectorAll('.pdot').forEach(function(d){
    var cu=parseFloat(d.dataset.u), cv=parseFloat(d.dataset.v);
    var pc=el('pickCanvas');
    var sx=cu*pc.width*vpScale+vpOx;
    var sy=cv*pc.height*vpScale+vpOy;
    d.style.left=sx+'px'; d.style.top=sy+'px';
  });
}

function clampVP(){
  var pc=el('pickCanvas'), vp=el('pickViewport');
  var vw=vp.clientWidth, vh=vp.clientHeight;
  var iw=pc.width*vpScale, ih=pc.height*vpScale;
  /* Allow up to 80% of image to go off-screen for edge detail */
  var margin=0.8;
  vpOx=Math.min(vw*margin, Math.max(-(iw*margin), vpOx));
  vpOy=Math.min(vh*margin, Math.max(-(ih*margin), vpOy));
}

function zoomAround(newScale, cx, cy){
  /* cx,cy in viewport coords â€” keep that point fixed */
  newScale=Math.max(0.3, Math.min(8, newScale));
  var ratio=newScale/vpScale;
  vpOx=cx-(cx-vpOx)*ratio;
  vpOy=cy-(cy-vpOy)*ratio;
  vpScale=newScale;
  clampVP(); applyVP();
}

function resetVP(){
  var pc=el('pickCanvas'), vp=el('pickViewport');
  var vw=vp.clientWidth, vh=vp.clientHeight;
  var fitW=vw/pc.width, fitH=vh/pc.height;
  vpScale=Math.min(fitW, fitH, 1);
  vpOx=(vw-pc.width*vpScale)/2;
  vpOy=(vh-pc.height*vpScale)/2;
  applyVP();
}

el('zoomIn').addEventListener('click',function(){
  var vp=el('pickViewport');
  zoomAround(vpScale*1.5, vp.clientWidth/2, vp.clientHeight/2);
});
el('zoomOut').addEventListener('click',function(){
  var vp=el('pickViewport');
  zoomAround(vpScale/1.5, vp.clientWidth/2, vp.clientHeight/2);
});
el('zoomReset').addEventListener('click',function(){ resetVP(); });

/* Viewport touch/mouse pan + pinch-zoom */
(function(){
  var vp=el('pickViewport');
  var touches={};

  function ptDist(a,b){ var dx=b.x-a.x,dy=b.y-a.y; return Math.sqrt(dx*dx+dy*dy); }
  function ptMid(a,b){ return{x:(a.x+b.x)/2,y:(a.y+b.y)/2}; }
  function vpXY(e){ var r=vp.getBoundingClientRect(); return{x:e.clientX-r.left,y:e.clientY-r.top}; }

  /* --- Touch --- */
  vp.addEventListener('touchstart',function(e){
    for(var i=0;i<e.changedTouches.length;i++){
      var t=e.changedTouches[i];
      touches[t.identifier]={x:t.clientX,y:t.clientY};
    }
    var ids=Object.keys(touches);
    if(ids.length===1){
      vpDragStart={x:touches[ids[0]].x,y:touches[ids[0]].y};
      vpDragOrigin={x:vpOx,y:vpOy};
    } else if(ids.length===2){
      var a=touches[ids[0]],b=touches[ids[1]];
      vpPinchDist0=ptDist(a,b); vpPinchScale0=vpScale; vpPinchMid=ptMid(a,b);
      var r=vp.getBoundingClientRect();
      vpPinchMid={x:vpPinchMid.x-r.left,y:vpPinchMid.y-r.top};
    }
  },{passive:true});

  vp.addEventListener('touchmove',function(e){
    e.preventDefault();
    for(var i=0;i<e.changedTouches.length;i++){
      var t=e.changedTouches[i];
      touches[t.identifier]={x:t.clientX,y:t.clientY};
    }
    var ids=Object.keys(touches);
    if(ids.length===1&&vpDragStart&&pickMode==='anchor'){
      /* Single finger pan (only in anchor mode â€” ruler needs single touch for drawing) */
      var dx=touches[ids[0]].x-vpDragStart.x, dy=touches[ids[0]].y-vpDragStart.y;
      vpOx=vpDragOrigin.x+dx; vpOy=vpDragOrigin.y+dy;
      clampVP(); applyVP();
    } else if(ids.length===2&&vpPinchDist0){
      var a=touches[ids[0]],b=touches[ids[1]];
      var newDist=ptDist(a,b);
      var newScale=vpPinchScale0*(newDist/vpPinchDist0);
      zoomAround(newScale, vpPinchMid.x, vpPinchMid.y);
    }
  },{passive:false});

  vp.addEventListener('touchend',function(e){
    for(var i=0;i<e.changedTouches.length;i++) delete touches[e.changedTouches[i].identifier];
    if(Object.keys(touches).length===0){ vpDragStart=null; vpPinchDist0=null; }
  },{passive:true});

  /* --- Mouse wheel zoom --- */
  vp.addEventListener('wheel',function(e){
    e.preventDefault();
    var r=vp.getBoundingClientRect();
    var cx=e.clientX-r.left, cy=e.clientY-r.top;
    zoomAround(vpScale*(e.deltaY<0?1.15:0.87), cx, cy);
  },{passive:false});

  /* --- Mouse pan --- */
  var mouseDragging=false;
  vp.addEventListener('mousedown',function(e){
    if(pickMode==='ruler') return;
    mouseDragging=true;
    vpDragStart={x:e.clientX,y:e.clientY};
    vpDragOrigin={x:vpOx,y:vpOy};
    vp.style.cursor='grabbing';
  });
  window.addEventListener('mousemove',function(e){
    if(!mouseDragging) return;
    vpOx=vpDragOrigin.x+(e.clientX-vpDragStart.x);
    vpOy=vpDragOrigin.y+(e.clientY-vpDragStart.y);
    clampVP(); applyVP();
  });
  window.addEventListener('mouseup',function(){
    mouseDragging=false;
    el('pickViewport').style.cursor=pickMode==='ruler'?'crosshair':'crosshair';
  });
})();

/* â”€â”€ Ruler SVG drawing in ruler tab â”€â”€ */
function initRulerOverlay(){
  var vp=el('pickViewport');
  var old=vp.querySelector('#rulerSvg'); if(old)old.remove();
  var pc=el('pickCanvas');

  /* SVG sits on top of canvas, same intrinsic size, transform-synced by applyVP */
  var svg=document.createElementNS('http://www.w3.org/2000/svg','svg');
  svg.id='rulerSvg';
  svg.setAttribute('width',pc.width); svg.setAttribute('height',pc.height);
  svg.style.cssText='position:absolute;top:0;left:0;transform-origin:0 0;pointer-events:all;display:none;overflow:visible;';
  var line=document.createElementNS('http://www.w3.org/2000/svg','line');
  line.setAttribute('stroke','#f0d060'); line.setAttribute('stroke-width','2');
  line.setAttribute('stroke-dasharray','6 3'); line.setAttribute('display','none');
  var c1=document.createElementNS('http://www.w3.org/2000/svg','circle');
  c1.setAttribute('r','6'); c1.setAttribute('fill','#f0d060'); c1.setAttribute('display','none');
  var c2=document.createElementNS('http://www.w3.org/2000/svg','circle');
  c2.setAttribute('r','6'); c2.setAttribute('fill','#f0d060'); c2.setAttribute('display','none');
  var txt=document.createElementNS('http://www.w3.org/2000/svg','text');
  txt.setAttribute('fill','#f0d060'); txt.setAttribute('font-size','14');
  txt.setAttribute('font-family','Space Mono,monospace'); txt.setAttribute('display','none');
  svg.appendChild(line); svg.appendChild(c1); svg.appendChild(c2); svg.appendChild(txt);
  vp.appendChild(svg);
  rulerLine=line;

  /* Convert viewport coords â†’ canvas image coords */
  function toCanvas(ex,ey){
    var r=vp.getBoundingClientRect();
    var vx=ex-r.left, vy=ey-r.top;
    return{x:(vx-vpOx)/vpScale, y:(vy-vpOy)/vpScale};
  }
  function getTouch(e){ return e.touches?e.touches[0]:e; }

  svg.addEventListener('mousedown',rulerDown);
  svg.addEventListener('touchstart',function(e){ e.preventDefault(); rulerDown(e.touches[0]); },{passive:false});

  function rulerDown(e){
    if(!rulerMode)return;
    var p=toCanvas(e.clientX,e.clientY);
    rulerP1={x:p.x,y:p.y}; rulerP2=null;
    c1.setAttribute('cx',p.x); c1.setAttribute('cy',p.y); c1.setAttribute('display','');
    c2.setAttribute('display','none'); line.setAttribute('display','none'); txt.setAttribute('display','none');
    el('rulerStatus').textContent='Drag to end pointâ€¦';
    el('rulerConfirmBtn').disabled=true;
  }
  svg.addEventListener('mousemove',rulerMove);
  svg.addEventListener('touchmove',function(e){ e.preventDefault(); rulerMove(e.touches[0]); },{passive:false});
  function rulerMove(e){
    if(!rulerMode||!rulerP1)return;
    var p=toCanvas(e.clientX,e.clientY);
    line.setAttribute('x1',rulerP1.x); line.setAttribute('y1',rulerP1.y);
    line.setAttribute('x2',p.x); line.setAttribute('y2',p.y); line.setAttribute('display','');
    c2.setAttribute('cx',p.x); c2.setAttribute('cy',p.y); c2.setAttribute('display','');
    var du=p.x-rulerP1.x, dv=p.y-rulerP1.y;
    var px=Math.round(Math.sqrt(du*du+dv*dv));
    txt.setAttribute('x',(rulerP1.x+p.x)/2+4); txt.setAttribute('y',(rulerP1.y+p.y)/2-6);
    txt.textContent=px+'px'; txt.setAttribute('display','');
  }
  svg.addEventListener('mouseup',rulerUp);
  svg.addEventListener('touchend',function(e){ e.preventDefault(); rulerUp(getTouch(e.changedTouches[0]||e)); },{passive:false});
  function rulerUp(e){
    if(!rulerMode||!rulerP1)return;
    var p=toCanvas(e.clientX,e.clientY);
    rulerP2={x:p.x,y:p.y};
    var du=(rulerP2.x-rulerP1.x)/el('pickCanvas').width;
    var dv=(rulerP2.y-rulerP1.y)/el('pickCanvas').height;
    var uvDist=Math.sqrt(du*du+dv*dv);
    var pxDist=Math.sqrt((rulerP2.x-rulerP1.x)**2+(rulerP2.y-rulerP1.y)**2);
    el('rulerStatus').textContent=Math.round(pxDist)+'px â€” enter real distance:';
    el('rulerConfirmBtn').disabled=uvDist<0.005;
  }
}

el('rulerConfirmBtn').addEventListener('click',function(){
  if(!rulerP1||!rulerP2)return;
  var realMetres=parseFloat(el('rulerDistInput').value);
  if(!realMetres||realMetres<=0){ el('rulerStatus').textContent='Enter a valid distance'; return; }
  var du=(rulerP2.x-rulerP1.x)/el('pickCanvas').width;
  var dv=(rulerP2.y-rulerP1.y)/el('pickCanvas').height;
  var asp=pdfCanvas.width/pdfCanvas.height;
  var uvDist=Math.sqrt(du*du+(dv*asp)*(dv*asp));
  metersPerUV=realMetres/uvDist;
  el('rulerStatus').textContent='\u2714 Scale set â€” '+realMetres+'m = '+Math.round(Math.sqrt((rulerP2.x-rulerP1.x)**2+(rulerP2.y-rulerP1.y)**2))+'px';
  el('rulerConfirmBtn').disabled=true;
  /* Switch back to anchor tab */
  setPickTab('anchor');
});

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   MEASUREMENT TOOL
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function enterMeasureMode(){
  measureMode=true; measurePt1=null; measurePt2=null;
  clearMeasureVisuals();
  el('normalBtns').style.display='none';
  el('measureBtns').style.display='flex';
  hide('measureLabel');
  el('hudHint').textContent='Tap floor for point 1\u2026';
}
function exitMeasureMode(){
  measureMode=false; measurePt1=null; measurePt2=null;
  clearMeasureVisuals();
  el('normalBtns').style.display='flex';
  el('measureBtns').style.display='none';
  hide('measureLabel');
  el('hudHint').textContent=wxrPlaced?'Plan placed \u2022 Tap to measure':'Point camera at the ground';
}
function clearMeasureVisuals(){
  if(!scene)return;
  if(measureLine){scene.remove(measureLine);measureLine=null;}
  measureDots.forEach(function(d){scene.remove(d);}); measureDots=[];
}
function buildMeasureLine(a,b){
  clearMeasureVisuals();
  [a,b].forEach(function(p){
    var dot=new THREE.Mesh(new THREE.SphereGeometry(0.028,10,10),new THREE.MeshBasicMaterial({color:0xf0d060}));
    dot.position.set(p.x,p.y+0.028,p.z); scene.add(dot); measureDots.push(dot);
  });
  var geo=new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(a.x,a.y+0.015,a.z),
    new THREE.Vector3(b.x,b.y+0.015,b.z)
  ]);
  measureLine=new THREE.Line(geo,new THREE.LineBasicMaterial({color:0xf0d060,linewidth:2}));
  scene.add(measureLine);
}
function updateMeasureLabel(worldA, worldB){
  // Calculate raw 3D distance
  var dx=worldB.x-worldA.x, dy=worldB.y-worldA.y, dz=worldB.z-worldA.z;
  var dist3D=Math.sqrt(dx*dx+dy*dy+dz*dz);
  var label=el('measureLabel');
  if(metersPerUV){
    // We have a user-set scale â€” but note: if plan is bound, world coords ARE metric already.
    // metersPerUV was set in UV space. World metres are actual AR metres.
    label.textContent=dist3D.toFixed(2)+' m';
  } else {
    label.textContent=dist3D.toFixed(2)+' m (AR)';
  }
  // Project midpoint to screen
  var mid=new THREE.Vector3((worldA.x+worldB.x)/2,(worldA.y+worldB.y)/2+0.06,(worldA.z+worldB.z)/2);
  var proj=mid.clone().project(camera);
  var sx=(proj.x*0.5+0.5)*window.innerWidth;
  var sy=(-proj.y*0.5+0.5)*window.innerHeight;
  label.style.left=sx+'px'; label.style.top=sy+'px';
  show('measureLabel');
}

el('measureBtn').addEventListener('click',function(){
  if(!wxrPlaced&&!wxrFloorFound){el('hudHint').textContent='Place the plan first';return;}
  enterMeasureMode();
});
el('measureClearBtn').addEventListener('click',function(){
  measurePt1=null; measurePt2=null; clearMeasureVisuals(); hide('measureLabel');
  el('hudHint').textContent='Tap floor for point 1\u2026';
});
el('measureExitBtn').addEventListener('click',exitMeasureMode);

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   GPS Â· COMPASS Â· WAYPOINTS Â· DRIFT ANALYSIS
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

   GPS state
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
var gpsEnabled=false;
var gpsWatchId=null;
var gpsLat=null, gpsLng=null, gpsAcc=null, gpsAlt=null;
var gpsFix=null;          // latest GeolocationPosition

/* Compass state */
var compassHeading=null;          // degrees true (0=N, 90=E)
var compassListening=false;

/* Waypoints â€” each: { id, gps:{lat,lng,acc}, world:{x,y,z}, label, dot:THREE.Mesh, labelEl } */
var waypoints=[];
var WP_COLORS=[0x4da6ff,0xe030f0,0x30e0f0,0xf09030,0xff88aa];

/* â”€â”€ Geolocation helpers â”€â”€ */
function haversineM(lat1,lng1,lat2,lng2){
  var R=6371000, dLat=(lat2-lat1)*Math.PI/180, dLng=(lng2-lng1)*Math.PI/180;
  var a=Math.sin(dLat/2)*Math.sin(dLat/2)+
        Math.cos(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180)*
        Math.sin(dLng/2)*Math.sin(dLng/2);
  return R*2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));
}
function bearingDeg(lat1,lng1,lat2,lng2){
  var dLng=(lng2-lng1)*Math.PI/180;
  var y=Math.sin(dLng)*Math.cos(lat2*Math.PI/180);
  var x=Math.cos(lat1*Math.PI/180)*Math.sin(lat2*Math.PI/180)-
        Math.sin(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180)*Math.cos(dLng);
  return (Math.atan2(y,x)*180/Math.PI+360)%360;
}
function fmtCoord(v,pos,neg){ return Math.abs(v).toFixed(6)+'\u00b0 '+(v>=0?pos:neg); }
function fmtAcc(a){ return a<5?'Â±'+a.toFixed(1)+'m':a<20?'Â±'+Math.round(a)+'m':'Â±'+Math.round(a)+'m âš '; }

function accClass(a){ return a==null?'red':a<10?'green':a<30?'yellow':'red'; }

/* â”€â”€ Start/stop GPS â”€â”€ */
function startGPS(){
  if(!navigator.geolocation){ el('gpsCoordsText').textContent='Geolocation not supported'; return; }
  gpsEnabled=true;
  el('gpsPanel').classList.add('show');
  el('dropPinBtn').style.display='';
  el('gpsToggleBtn').className='hud-btn g';
  el('gpsToggleBtn').textContent='\uD83D\uDEF0 GPS On';
  gpsWatchId=navigator.geolocation.watchPosition(
    onGpsFix, onGpsErr,
    {enableHighAccuracy:true, maximumAge:2000, timeout:10000}
  );
  startCompass();
  show('gpsMap'); renderMiniMap();
}
function stopGPS(){
  gpsEnabled=false;
  if(gpsWatchId!=null){ navigator.geolocation.clearWatch(gpsWatchId); gpsWatchId=null; }
  el('gpsPanel').classList.remove('show');
  el('dropPinBtn').style.display='none';
  el('gpsToggleBtn').className='hud-btn';
  el('gpsToggleBtn').textContent='\uD83D\uDEF0 GPS';
  hide('gpsMap');
  stopCompass();
}

function onGpsFix(pos){
  gpsFix=pos;
  gpsLat=pos.coords.latitude; gpsLng=pos.coords.longitude;
  gpsAcc=pos.coords.accuracy; gpsAlt=pos.coords.altitude;
  updateGPSBadge();
  ingestGPSForBearing(gpsLat,gpsLng,gpsAcc);
  updateSensorCard();   /* updates step-0 card if we're still there */
  var paired=waypoints.filter(function(w){return w.gps&&w.world;});
  if(paired.length>=2) runDriftAnalysis(paired);
}
function onGpsErr(e){ el('gpsCoordsText').textContent='GPS error: '+e.message; }

function updateGPSBadge(){
  if(gpsLat==null)return;
  el('gpsCoordsText').textContent=fmtCoord(gpsLat,'N','S')+'  '+fmtCoord(gpsLng,'E','W');
  el('gpsAccText').textContent='acc: '+fmtAcc(gpsAcc)+(gpsAlt!=null?' Â· alt: '+Math.round(gpsAlt)+'m':'');
  var dot=el('gpsAccDot');
  dot.className=''; dot.classList.add(accClass(gpsAcc));
  renderMiniMap();
}

/* â”€â”€ Compass (DeviceOrientationEvent) â”€â”€ */
function startCompass(){
  if(compassListening)return;
  function handler(e){
    var ts=performance.now();
    /* Absolute heading */
    var h=null;
    if(e.webkitCompassHeading!=null){ h=e.webkitCompassHeading; }
    else if(e.absolute&&e.alpha!=null){ h=(360-e.alpha)%360; }
    else if(e.alpha!=null){ h=(360-e.alpha)%360; }
    if(h==null)return;
    compassHeading=h;
    updateCompassBadge(h);
    var alphaRaw=e.alpha||0;
    updateFusedHeading(h, alphaRaw, ts);
    updateSensorCard();  /* refresh compass status on step-0 card */
  }
  if(typeof DeviceOrientationEvent!=='undefined'&&
     typeof DeviceOrientationEvent.requestPermission==='function'){
    DeviceOrientationEvent.requestPermission().then(function(s){
      if(s==='granted'){ window.addEventListener('deviceorientation',handler,true); compassListening=true; }
    }).catch(function(){});
  } else {
    window.addEventListener('deviceorientation',handler,true);
    compassListening=true;
  }
}
function stopCompass(){
  /* We can't easily remove anonymous listener but gpsEnabled gate stops updates */
  compassListening=false;
}
function updateCompassBadge(h){
  if(!gpsEnabled)return;
  el('compassHeadingText').textContent=Math.round(h)+'\u00b0';
  var dirs=['N','NE','E','SE','S','SW','W','NW','N'];
  el('compassDirText').textContent=dirs[Math.round(h/45)%8];
  /* Rotate compass rose â€” needle points to N, so rotate svg by -heading to keep N up */
  el('compassSvg').style.transform='rotate('+(-h)+'deg)';
}

/* â”€â”€ GPS Toggle button â”€â”€ */
el('gpsToggleBtn').addEventListener('click',function(){
  if(gpsEnabled) stopGPS(); else startGPS();
});

/* â”€â”€ Drop Pin â”€â”€ */
el('dropPinBtn').addEventListener('click',function(){
  if(!reticle||!reticle.visible){ el('hudHint').textContent='Point camera at ground to place pin'; return; }
  if(gpsLat==null){ el('gpsCoordsText').textContent='No GPS fix yet â€” wait for signal'; return; }
  if(gpsAcc>25){ el('gpsAccText').textContent='Accuracy \u00b1'+Math.round(gpsAcc)+'m \u2014 move to open sky'; return; }

  var rx=reticle.matrix.elements[12],ry=reticle.matrix.elements[13],rz=reticle.matrix.elements[14];
  var fp=currentSnap?{x:currentSnap.x,y:currentSnap.y,z:currentSnap.z}:{x:rx,y:ry,z:rz};
  var idx=waypoints.length;
  var col=WP_COLORS[idx%WP_COLORS.length];

  /* 3D dot */
  var dot=new THREE.Mesh(
    new THREE.SphereGeometry(0.045,12,12),
    new THREE.MeshBasicMaterial({color:col})
  );
  dot.position.set(fp.x,fp.y+0.045,fp.z);
  scene.add(dot);

  /* DOM label */
  var lbl=document.createElement('div');
  lbl.className='wp-label';
  lbl.textContent='WP'+(idx+1)+' Â±'+Math.round(gpsAcc)+'m';
  lbl.style.background='#'+col.toString(16).padStart(6,'0');
  lbl.style.color=col>0x888888?'#04050f':'#ffffff';
  el('wpLabels').appendChild(lbl);

  var wp={
    id:idx+1,
    gps:{lat:gpsLat,lng:gpsLng,acc:gpsAcc},
    world:{x:fp.x,y:fp.y,z:fp.z},
    dot:dot, labelEl:lbl
  };
  waypoints.push(wp);

  el('hudHint').textContent='WP'+(idx+1)+' pinned â€¢ GPS Â±'+Math.round(gpsAcc)+'m';
  renderMiniMap();

  /* Immediately run analysis if we have enough */
  var paired=waypoints.filter(function(w){return w.gps&&w.world;});
  if(paired.length>=2) runDriftAnalysis(paired);
});

/* â”€â”€ Drift Analysis â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   For each pair of waypoints we compare:
     GPS distance between them  (haversine metres)
     XR world distance between them  (3D euclidean, XZ only for floor)
   The ratio tells us if the XR scale is off.
   We also compute how much the current GPS fix would imply the plan
   origin has drifted from its XR position.
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function runDriftAnalysis(paired){
  var errors=[];
  for(var i=0;i<paired.length-1;i++){
    for(var j=i+1;j<paired.length;j++){
      var a=paired[i], b=paired[j];
      var gpsDist=haversineM(a.gps.lat,a.gps.lng,b.gps.lat,b.gps.lng);
      var dx=b.world.x-a.world.x, dz=b.world.z-a.world.z;
      var xrDist=Math.sqrt(dx*dx+dz*dz);
      if(xrDist<0.01)continue;
      var ratio=gpsDist/xrDist;     // 1.0 = perfect, >1 XR is compressed, <1 expanded
      var scalePct=Math.abs(ratio-1)*100;
      /* Combined GPS accuracy budget for this pair */
      var accBudget=Math.sqrt(a.gps.acc*a.gps.acc+b.gps.acc*b.gps.acc);
      errors.push({gpsDist:gpsDist,xrDist:xrDist,ratio:ratio,scalePct:scalePct,accBudget:accBudget,i:i,j:j});
    }
  }
  if(errors.length===0)return;

  /* Mean scale error */
  var meanScale=errors.reduce(function(s,e){return s+e.scalePct;},0)/errors.length;
  var meanAcc=errors.reduce(function(s,e){return s+e.accBudget;},0)/errors.length;

  /* Current GPS fix vs nearest waypoint XR anchor â€” positional drift */
  var driftM=null;
  if(gpsLat!=null&&paired.length>0){
    /* Use WP with best GPS accuracy */
    var best=paired.slice().sort(function(a,b){return a.gps.acc-b.gps.acc;})[0];
    var gpsDelta=haversineM(gpsLat,gpsLng,best.gps.lat,best.gps.lng);
    var bearing=bearingDeg(best.gps.lat,best.gps.lng,gpsLat,gpsLng);
    /* Current XR camera position (approximate â€” we don't have it directly,
       but we can warn if the GPS delta is large compared to accuracy) */
    driftM=gpsDelta; /* relative to best waypoint GPS origin */
  }

  /* Compose status message */
  var badge=el('gpsDriftBadge');
  var cls='ok', msg='';
  if(meanScale<5&&(driftM==null||driftM<meanAcc)){
    cls='ok';
    msg='\u2714 Scale OK (\u00b1'+meanScale.toFixed(1)+'%) \u2022 GPS Â±'+Math.round(meanAcc)+'m';
  } else if(meanScale<15){
    cls='warn';
    msg='\u26A0 Scale drift '+meanScale.toFixed(1)+'% \u2022 GPS Â±'+Math.round(meanAcc)+'m';
  } else {
    cls='bad';
    msg='\u26D4 Scale drift '+meanScale.toFixed(1)+'% â€” check anchors';
  }
  if(driftM!=null&&driftM>meanAcc){
    msg+='\n\u21BA Pos drift ~'+driftM.toFixed(1)+'m from WP1';
    if(cls==='ok')cls='warn';
  }
  badge.textContent=msg; badge.className=''; badge.classList.add('show',cls);
}

/* â”€â”€ GPS Minimap â”€â”€ */
function renderMiniMap(){
  if(!gpsEnabled)return;
  var c=el('gpsMapCanvas'), ctx=c.getContext('2d');
  var W=140,H=140;
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle='rgba(4,5,15,.95)'; ctx.fillRect(0,0,W,H);

  /* Grid */
  ctx.strokeStyle='rgba(77,166,255,.1)'; ctx.lineWidth=1;
  for(var g=0;g<W;g+=14){ ctx.beginPath(); ctx.moveTo(g,0); ctx.lineTo(g,H); ctx.stroke(); }
  for(var g2=0;g2<H;g2+=14){ ctx.beginPath(); ctx.moveTo(0,g2); ctx.lineTo(W,g2); ctx.stroke(); }

  /* Cross-hair centre */
  ctx.strokeStyle='rgba(77,166,255,.25)'; ctx.lineWidth=1;
  ctx.beginPath(); ctx.moveTo(W/2,0); ctx.lineTo(W/2,H); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(0,H/2); ctx.lineTo(W,H/2); ctx.stroke();

  if(waypoints.length===0&&gpsLat==null){ return; }

  /* Gather all points including current fix */
  var pts=waypoints.map(function(w){return{lat:w.gps.lat,lng:w.gps.lng,wp:w};});
  if(gpsLat!=null) pts.push({lat:gpsLat,lng:gpsLng,current:true});

  if(pts.length===0)return;

  /* Bounds */
  var lats=pts.map(function(p){return p.lat;}), lngs=pts.map(function(p){return p.lng;});
  var minLat=Math.min.apply(null,lats),maxLat=Math.max.apply(null,lats);
  var minLng=Math.min.apply(null,lngs),maxLng=Math.max.apply(null,lngs);
  var spanLat=maxLat-minLat||0.0001, spanLng=maxLng-minLng||0.0001;
  /* Add 20% padding */
  var padLat=spanLat*0.25, padLng=spanLng*0.25;
  var L0=minLat-padLat, L1=maxLat+padLat, G0=minLng-padLng, G1=maxLng+padLng;

  function toXY(lat,lng){
    return{
      x:(lng-G0)/(G1-G0)*(W-16)+8,
      y:(1-(lat-L0)/(L1-L0))*(H-16)+8
    };
  }

  /* Draw lines between waypoints in order */
  if(waypoints.length>=2){
    ctx.strokeStyle='rgba(77,166,255,.35)'; ctx.lineWidth=1.5; ctx.setLineDash([3,3]);
    ctx.beginPath();
    waypoints.forEach(function(w,i){
      var p=toXY(w.gps.lat,w.gps.lng);
      if(i===0)ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
    });
    ctx.stroke(); ctx.setLineDash([]);
  }

  /* Accuracy circle for current fix */
  if(gpsLat!=null&&gpsAcc!=null){
    var cp=toXY(gpsLat,gpsLng);
    /* convert accuracy to pixels â€” very rough: 1 deg lat â‰ˆ 111km */
    var accPx=gpsAcc/111000*(H-16)/(L1-L0)*0.5;
    ctx.beginPath(); ctx.arc(cp.x,cp.y,Math.max(3,accPx),0,Math.PI*2);
    ctx.fillStyle='rgba(232,79,43,.08)'; ctx.fill();
    ctx.strokeStyle='rgba(232,79,43,.3)'; ctx.lineWidth=1; ctx.stroke();
  }

  /* Waypoint dots */
  waypoints.forEach(function(w){
    var p=toXY(w.gps.lat,w.gps.lng);
    var hexCol='#'+(WP_COLORS[(w.id-1)%WP_COLORS.length]).toString(16).padStart(6,'0');
    ctx.beginPath(); ctx.arc(p.x,p.y,5,0,Math.PI*2);
    ctx.fillStyle=hexCol; ctx.fill();
    ctx.fillStyle='#fff'; ctx.font='bold 8px monospace';
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(w.id,p.x,p.y);
    /* Accuracy ring */
    if(w.gps.acc!=null){
      var acp=w.gps.acc/111000*(H-16)/(L1-L0)*0.5;
      ctx.beginPath(); ctx.arc(p.x,p.y,Math.max(5,acp),0,Math.PI*2);
      ctx.strokeStyle=hexCol+'55'; ctx.lineWidth=1; ctx.stroke();
    }
  });

  /* Current GPS position */
  if(gpsLat!=null){
    var cp2=toXY(gpsLat,gpsLng);
    ctx.beginPath(); ctx.arc(cp2.x,cp2.y,5,0,Math.PI*2);
    ctx.fillStyle='var(--accent)'; ctx.fill();
    /* Compass direction wedge */
    if(compassHeading!=null){
      var hRad=compassHeading*Math.PI/180;
      ctx.beginPath(); ctx.moveTo(cp2.x,cp2.y);
      ctx.lineTo(cp2.x+Math.sin(hRad)*14,cp2.y-Math.cos(hRad)*14);
      ctx.strokeStyle='rgba(232,79,43,.7)'; ctx.lineWidth=1.5; ctx.stroke();
    }
    /* Label */
    ctx.fillStyle='rgba(232,79,43,.9)'; ctx.font='7px monospace';
    ctx.textAlign='center'; ctx.textBaseline='bottom';
    ctx.fillText('YOU',cp2.x,cp2.y-7);
  }

  /* N arrow */
  ctx.fillStyle='rgba(232,79,43,.7)'; ctx.font='bold 9px monospace';
  ctx.textAlign='left'; ctx.textBaseline='top';
  ctx.fillText('N\u2191',4,4);
}

/* â”€â”€ Update waypoint DOM labels each frame (project 3Dâ†’2D) â”€â”€ */
function updateWaypointLabels(){
  if(!camera||waypoints.length===0)return;
  waypoints.forEach(function(w){
    if(!w.labelEl||!w.world)return;
    var v=new THREE.Vector3(w.world.x,w.world.y+0.25,w.world.z);
    var proj=v.clone().project(camera);
    if(proj.z>1){ w.labelEl.style.display='none'; return; } /* behind camera */
    var sx=(proj.x*.5+.5)*window.innerWidth;
    var sy=(-.5*proj.y+.5)*window.innerHeight;
    w.labelEl.style.display='';
    w.labelEl.style.left=sx+'px';
    w.labelEl.style.top=sy+'px';
  });
}

/* Clear waypoints on full reset */
function clearWaypoints(){
  waypoints.forEach(function(w){
    if(w.dot&&scene)scene.remove(w.dot);
    if(w.labelEl&&w.labelEl.parentNode)w.labelEl.parentNode.removeChild(w.labelEl);
  });
  waypoints=[];
  var badge=el('gpsDriftBadge'); badge.className=''; badge.textContent='';
  renderMiniMap();
}


function openPickOverlay(){
  uvPicks=[];
  var N=corners.length;
  el('pickTitle').textContent='PICK '+N+' COLUMNS ON THE PLAN';
  el('pickInfo').textContent='0 / '+N;
  el('pickSub').textContent='Hold on column 1';
  el('pickConfirmBtn').disabled=true;
  el('rulerStatus').textContent='Drag a line across a known dimension';
  el('rulerDistInput').value='';
  el('rulerConfirmBtn').disabled=true;
  rulerP1=null; rulerP2=null;

  /* Size canvas to PDF aspect, high res for zoom */
  var pc=el('pickCanvas');
  var NATIVE_W=Math.min(pdfCanvas.width, 2048);
  var NATIVE_H=Math.round(NATIVE_W*(pdfCanvas.height/pdfCanvas.width));
  pc.width=NATIVE_W; pc.height=NATIVE_H;
  pc.getContext('2d').drawImage(pdfCanvas,0,0,NATIVE_W,NATIVE_H);

  /* Clear old dots */
  el('pickViewport').querySelectorAll('.pdot').forEach(function(d){d.remove();});

  el('pickOverlay').classList.add('show');
  setPickTab('anchor');

  /* Reset zoom to fit */
  setTimeout(function(){
    resetVP();
    initRulerOverlay();
  }, 30);

  /* Hold-to-place on PDF canvas â€” press and hold 500ms to commit a column pick */
  var PICK_HOLD_MS = 500;
  var pickHoldTimer=null, pickHoldPos=null;
  var pickHoldIndicator=null;  /* a small SVG ring shown during hold */

  function getOrCreateHoldIndicator(){
    var svg=el('pickViewport').querySelector('#holdIndicatorSvg');
    if(svg) return svg;
    svg=document.createElementNS('http://www.w3.org/2000/svg','svg');
    svg.id='holdIndicatorSvg';
    svg.style.cssText='position:absolute;top:0;left:0;pointer-events:none;z-index:30;overflow:visible;';
    svg.setAttribute('width','100%'); svg.setAttribute('height','100%');
    /* arc circle */
    var circ=document.createElementNS('http://www.w3.org/2000/svg','circle');
    circ.id='holdArc'; circ.setAttribute('r','22'); circ.setAttribute('fill','none');
    circ.setAttribute('stroke','#2be87a'); circ.setAttribute('stroke-width','3');
    circ.setAttribute('stroke-dasharray','0 200'); circ.setAttribute('stroke-linecap','round');
    circ.setAttribute('transform','rotate(-90)');
    /* bg ring */
    var bg=document.createElementNS('http://www.w3.org/2000/svg','circle');
    bg.setAttribute('r','22'); bg.setAttribute('fill','none');
    bg.setAttribute('stroke','rgba(255,255,255,.1)'); bg.setAttribute('stroke-width','2');
    svg.appendChild(bg); svg.appendChild(circ);
    el('pickViewport').appendChild(svg);
    return svg;
  }

  function showPickHold(vpx,vpy,frac){
    var svg=getOrCreateHoldIndicator();
    var arc=svg.querySelector('#holdArc');
    svg.querySelector('circle:not(#holdArc)').setAttribute('cx',vpx); svg.querySelector('circle:not(#holdArc)').setAttribute('cy',vpy);
    arc.setAttribute('cx',vpx); arc.setAttribute('cy',vpy);
    var circ=2*Math.PI*22;
    arc.setAttribute('stroke-dasharray',(circ*frac)+' '+(circ*(1-frac)));
    svg.style.display='block';
  }
  function hidePickHold(){
    var svg=el('pickViewport').querySelector('#holdIndicatorSvg');
    if(svg) svg.style.display='none';
    if(pickHoldTimer){clearTimeout(pickHoldTimer);pickHoldTimer=null;}
    pickHoldPos=null;
  }

  function commitPickAt(vpx,vpy){
    if(pickMode!=='anchor') return;
    if(uvPicks.length>=corners.length) return;
    var cx=(vpx-vpOx)/vpScale;
    var cy=(vpy-vpOy)/vpScale;
    var u=Math.max(0,Math.min(1,cx/pc.width));
    var v=Math.max(0,Math.min(1,cy/pc.height));
    uvPicks.push({u:u,v:v});
    var rawCol=CORNER_COLORS[(uvPicks.length-1)%CORNER_COLORS.length];
    var hexCol='#'+rawCol.toString(16).padStart(6,'0');
    var dot=document.createElement('div');
    dot.className='pdot';
    dot.dataset.u=u; dot.dataset.v=v;
    var sx=u*pc.width*vpScale+vpOx;
    var sy=v*pc.height*vpScale+vpOy;
    dot.style.cssText='position:absolute;width:22px;height:22px;border-radius:50%;'+
      'background:'+hexCol+';color:#000;font-family:Space Mono,monospace;font-size:10px;'+
      'font-weight:bold;display:flex;align-items:center;justify-content:center;'+
      'pointer-events:none;transform:translate(-50%,-50%);left:'+sx+'px;top:'+sy+'px;z-index:10;';
    dot.textContent=uvPicks.length;
    el('pickViewport').appendChild(dot);
    var rem=corners.length-uvPicks.length;
    el('pickInfo').textContent=uvPicks.length+' / '+N;
    el('pickSub').textContent=rem>0?'Hold on column '+(uvPicks.length+1):'\u2714 All picked â€” tap Bind';
    el('pickConfirmBtn').disabled=rem>0;
  }

  var vp=el('pickViewport');

  function startPickHold(vpx,vpy){
    if(pickMode!=='anchor') return;
    pickHoldPos={x:vpx,y:vpy,t:Date.now()};
    showPickHold(vpx,vpy,0);
    var interval=setInterval(function(){
      if(!pickHoldPos){clearInterval(interval);hidePickHold();return;}
      var frac=Math.min(1,(Date.now()-pickHoldPos.t)/PICK_HOLD_MS);
      showPickHold(pickHoldPos.x,pickHoldPos.y,frac);
      if(frac>=1){
        clearInterval(interval);
        commitPickAt(pickHoldPos.x,pickHoldPos.y);
        hidePickHold();
      }
    },16);
    pickHoldTimer=interval;
  }

  vp.ontouchstart=function(e){
    if(e.touches.length>1){hidePickHold();return;}
    var t=e.changedTouches[0];
    var r=vp.getBoundingClientRect();
    vp._tapStart={x:t.clientX,y:t.clientY,time:Date.now()};
    startPickHold(t.clientX-r.left,t.clientY-r.top);
  };
  vp.ontouchmove=function(e){
    var t=e.changedTouches[0];
    var ts=vp._tapStart;
    if(ts&&pickHoldTimer){
      var dx=t.clientX-ts.x, dy=t.clientY-ts.y;
      if(Math.sqrt(dx*dx+dy*dy)>8) hidePickHold(); /* cancel if moved */
    }
  };
  vp.ontouchend=function(e){
    hidePickHold();
    vp._tapStart=null;
  };
  vp.onmousedown=function(e){
    if(e.target.closest('.zoom-btn')) return;
    var r=vp.getBoundingClientRect();
    startPickHold(e.clientX-r.left,e.clientY-r.top);
  };
  vp.onmouseup=function(){ hidePickHold(); };
  vp.onmouseleave=function(){ hidePickHold(); };
}

el('pickUndoBtn').addEventListener('click',function(){
  if(uvPicks.length===0)return;
  uvPicks.pop();
  var dots=el('pickViewport').querySelectorAll('.pdot');
  if(dots.length>0)dots[dots.length-1].remove();
  var N=corners.length;
  el('pickInfo').textContent=uvPicks.length+' / '+N;
  el('pickSub').textContent=uvPicks.length<N?'Hold on column '+(uvPicks.length+1):'Hold on column '+N;
  el('pickConfirmBtn').disabled=true;
});
el('pickClearBtn').addEventListener('click',function(){
  uvPicks=[];
  el('pickViewport').querySelectorAll('.pdot').forEach(function(d){d.remove();});
  var N=corners.length;
  el('pickInfo').textContent='0 / '+N;
  el('pickSub').textContent='Hold on column 1';
  el('pickConfirmBtn').disabled=true;
});
el('pickCancelBtn').addEventListener('click',function(){
  closePickOverlay();
  showBtns('normal');
  el('hudHint').textContent='Tap Anchor to retry';
});
el('pickConfirmBtn').addEventListener('click',function(){
  if(uvPicks.length!==corners.length)return;
  closePickOverlay();
  buildBoundMesh();
  onPlanBound();   /* wizard step 4 â†’ 5 */
});
function closePickOverlay(){
  var vp=el('pickViewport');
  vp.onclick=null; vp.ontouchstart=null; vp.ontouchend=null;
  el('pickOverlay').classList.remove('show');
  rulerMode=false; rulerP1=null; rulerP2=null;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   KABSCH RIGID-BODY SOLVER
   Finds the best-fit translation + yaw rotation + uniform scale
   that maps plan UV points â†’ world XZ points.
   Returns {origin, yaw, scale, residualM} or null.

   Algorithm:
     1. Centre both point sets on their centroids
     2. Build 2Ã—2 cross-covariance matrix H = Î£ uváµ¢áµ€ Â· wáµ¢
     3. SVD of H â†’ U, S, Váµ€  (2D: analytical formula)
     4. R = V Â· Uáµ€  (optimal rotation)
     5. Scale = Î£|wáµ¢|Â² / Î£(uáµ¢Â·Ráµ€Â·wáµ¢)  (TLS scale)
     6. Translation from centroids
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function kabschSolve(corners, uvPicks){
  var N=corners.length;
  if(N<2) return null;

  /* Collect 2D points â€” world XZ and plan UV (centred on 0.5,0.5) */
  var wx=[],wz=[],pu=[],pv=[];
  for(var i=0;i<N;i++){
    wx.push(corners[i].worldPos.x); wz.push(corners[i].worldPos.z);
    pu.push(uvPicks[i].u-0.5);      pv.push(uvPicks[i].v-0.5);
  }

  /* Centroids */
  var cwx=wx.reduce(function(a,b){return a+b;},0)/N;
  var cwz=wz.reduce(function(a,b){return a+b;},0)/N;
  var cpu=pu.reduce(function(a,b){return a+b;},0)/N;
  var cpv=pv.reduce(function(a,b){return a+b;},0)/N;

  /* Centred coords */
  var Wx=wx.map(function(v){return v-cwx;});
  var Wz=wz.map(function(v){return v-cwz;});
  var Pu=pu.map(function(v){return v-cpu;});
  var Pv=pv.map(function(v){return v-cpv;});

  /* 2D cross-covariance H = Páµ€ W  (2Ã—2) */
  var h00=0,h01=0,h10=0,h11=0;
  for(var i=0;i<N;i++){
    h00+=Pu[i]*Wx[i]; h01+=Pu[i]*Wz[i];
    h10+=Pv[i]*Wx[i]; h11+=Pv[i]*Wz[i];
  }

  /* Analytical SVD of 2Ã—2 matrix H:
     Î¸ = 0.5Â·atan2(2Â·(h00Â·h10+h01Â·h11), h00Â²+h01Â²-h10Â²-h11Â²) */
  var theta=0.5*Math.atan2(2*(h00*h10+h01*h11),
                           h00*h00+h01*h01-h10*h10-h11*h11);
  var cosT=Math.cos(theta), sinT=Math.sin(theta);
  /* U = rotation matrix from theta */
  /* V from: H = UÂ·SÂ·Váµ€  â†’ Váµ€ = Sâ»Â¹Â·Uáµ€Â·H (approximate â€” use atan2 of HÂ·U) */
  var phi=Math.atan2(h10*cosT+h11*sinT, h00*cosT+h01*sinT);
  var cosP=Math.cos(phi), sinP=Math.sin(phi);

  /* Optimal rotation: R = VÂ·Uáµ€ â†’ yaw angle = phi - theta */
  var yaw=phi-theta;

  /* Ensure det(R)>0 (no reflection) */
  var detR=Math.cos(yaw);  /* det of 2D rotation = 1, always positive */

  /* Optimal scale: s = Î£(WÂ·RÂ·P) / Î£|P|Â² */
  var num=0, den=0;
  var cosY=Math.cos(yaw), sinY=Math.sin(yaw);
  for(var i=0;i<N;i++){
    var Ru=cosY*Pu[i]-sinY*Pv[i];
    var Rv=sinY*Pu[i]+cosY*Pv[i];
    num+=Wx[i]*Ru+Wz[i]*Rv;
    den+=Pu[i]*Pu[i]+Pv[i]*Pv[i];
  }
  var scale=(den>1e-10)?num/den:1;
  if(scale<0.01||scale>500) return null;  /* degenerate */

  /* Translation: t = Wcent - sÂ·RÂ·Pcent */
  var Rpu=cosY*cpu-sinY*cpv;
  var Rpv=sinY*cpu+cosY*cpv;
  var tx=cwx-scale*Rpu;
  var tz=cwz-scale*Rpv;

  /* Residual: mean reprojection error in metres */
  var resSum=0;
  for(var i=0;i<N;i++){
    var rpx=scale*(cosY*pu[i]-sinY*pv[i])+tx;
    var rpz=scale*(sinY*pu[i]+cosY*pv[i])+tz;
    var dx=wx[i]-rpx, dz=wz[i]-rpz;
    resSum+=Math.sqrt(dx*dx+dz*dz);
  }
  var residualM=resSum/N;

  return {tx:tx, tz:tz, yaw:yaw, scale:scale, residualM:residualM};
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   PLAN MESH GEOMETRY  (flat rectangle, UV 0-1 covering whole PDF)
   The mesh itself never deforms â€” we just move/rotate/scale the
   THREE.Group that holds it.
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
var planRigidGroup=null;   /* THREE.Group positioned by Kabsch each frame */

function buildBoundMesh(){
  if(corners.length<2||uvPicks.length!==corners.length){
    el('hudHint').textContent='Need at least 2 column anchors'; showBtns('normal'); return;
  }
  if(boundMesh&&scene){scene.remove(boundMesh);boundMesh=null;}
  if(planRigidGroup&&scene){scene.remove(planRigidGroup);planRigidGroup=null;}
  if(renderer){
    var maxTex=renderer.capabilities.maxTextureSize;
    if(pdfCanvas.width>maxTex||pdfCanvas.height>maxTex){
      var r=Math.min(maxTex/pdfCanvas.width,maxTex/pdfCanvas.height);
      var t=document.createElement('canvas');
      t.width=Math.floor(pdfCanvas.width*r); t.height=Math.floor(pdfCanvas.height*r);
      t.getContext('2d').drawImage(pdfCanvas,0,0,t.width,t.height); pdfCanvas=t;
    }
  }
  var tex=new THREE.Texture(pdfCanvas);
  tex.needsUpdate=true; tex.anisotropy=renderer?renderer.capabilities.getMaxAnisotropy():1;
  tex.minFilter=THREE.LinearMipmapLinearFilter; tex.magFilter=THREE.LinearFilter; tex.generateMipmaps=true;

  /* A flat plane: 1 UV unit = 1 metre initially; Kabsch scale corrects this.
     Plane is in XZ, centred at origin, UV 0,0 = bottom-left of PDF.         */
  var asp=pdfCanvas.width/pdfCanvas.height;
  var geo=new THREE.PlaneGeometry(asp,1,1,1);
  geo.applyMatrix4(new THREE.Matrix4().makeRotationX(-Math.PI/2));
  /* Flip UV V so PDF top = world north when yaw=0 */
  var uvAttr=geo.attributes.uv;
  for(var i=0;i<uvAttr.count;i++) uvAttr.setY(i,1-uvAttr.getY(i));
  uvAttr.needsUpdate=true;

  var mat=new THREE.MeshBasicMaterial({map:tex,transparent:true,opacity:xfOpacity,
                                        side:THREE.DoubleSide,depthWrite:false});
  boundMesh=new THREE.Mesh(geo,mat);

  planRigidGroup=new THREE.Group();
  planRigidGroup.add(boundMesh);
  scene.add(planRigidGroup);
  if(planeGroup)planeGroup.visible=false;

  /* Initial Kabsch solve */
  if(!reSolvePlan()){
    /* Fallback if only 2 points â€” place centred between them */
    planBound=true;
    applyRigidTransform(planOrigin.x,planOrigin.z,planYaw,planScale);
  }

  show('statusBar'); show('cornerBadge');
  el('cornerBadge').textContent='\u2714 Locked \u2022 '+corners.length+' column anchors';
  showBtns('normal');
  el('hudHint').textContent='Plan structure-locked \u2714 \u2022 All sensors active';
  el('hudHint').textContent='Plan rigid-locked to '+corners.length+' columns âœ”';
}

/* Apply the Kabsch transform to the planRigidGroup */
function applyRigidTransform(tx,tz,yaw,scale){
  if(!planRigidGroup)return;
  /* Y position: mean column Y */
  var meanY=corners.reduce(function(s,c){return s+c.worldPos.y;},0)/Math.max(corners.length,1);
  planRigidGroup.position.set(tx,meanY,tz);
  planRigidGroup.rotation.set(0,yaw,0);
  planRigidGroup.scale.set(scale,1,scale);
}

/* Run Kabsch â†’ update plan transform â†’ update status panel */
function reSolvePlan(){
  var t0=performance.now();
  var sol=kabschSolve(corners,uvPicks);
  if(!sol) return false;
  planOrigin.set(sol.tx,0,sol.tz);
  planYaw=sol.yaw;
  planScale=sol.scale;
  planBound=true;
  applyRigidTransform(sol.tx,sol.tz,sol.yaw,sol.scale);
  solveCount++;
  var ms=(performance.now()-t0).toFixed(1);
  var resStr=sol.residualM<0.005?'\u2714':sol.residualM<0.05?'\u26A0':'!';
  el('statusBar').textContent=
    corners.length+' col \u2022 res '+( sol.residualM*100).toFixed(1)+'cm '+resStr+
    ' \u2022 scale '+(sol.scale).toFixed(3)+'m/UV'+
    ' \u2022 #'+solveCount+' ('+ms+'ms)';
  constraintQuality.xrAnchor=Math.max(0,1-sol.residualM/0.1);
  updateConstraintPanel();
  updateBoundCard();   /* keep step-5 card quality live */
  return true;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   XR ANCHOR UPDATE  (called every frame when plan is bound)
   1. Pull updated anchor positions
   2. Re-snap columns to plane vertices every RESNAP_INTERVAL frames
   3. Re-run Kabsch if anything moved
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function updateAnchors(frame,refSpace){
  var moved=false;

  /* 1. XRAnchors drift correction */
  corners.forEach(function(c){
    if(!c.anchor)return;
    try{
      var ap=frame.getPose(c.anchor.anchorSpace,refSpace);
      if(!ap)return;
      var nx=ap.transform.position.x,ny=ap.transform.position.y,nz=ap.transform.position.z;
      if(Math.abs(nx-c.worldPos.x)+Math.abs(ny-c.worldPos.y)+Math.abs(nz-c.worldPos.z)>0.0005){
        c.worldPos={x:nx,y:ny,z:nz}; moved=true;
      }
    }catch(e){}
  });

  /* 2. Periodic plane-vertex re-snap */
  reSnapFrameCounter++;
  if(reSnapFrameCounter>=RESNAP_INTERVAL){
    reSnapFrameCounter=0;
    var snapMoved=false;
    corners.forEach(function(c){
      var pos=new THREE.Vector3(c.worldPos.x,c.worldPos.y,c.worldPos.z);
      var snapped=snapToNearestPlaneVertex(pos,frame,refSpace);
      if(!snapped)return;
      var dx=snapped.x-c.worldPos.x, dz=snapped.z-c.worldPos.z;
      var dist=Math.sqrt(dx*dx+dz*dz);
      if(dist>0.005&&dist<RESNAP_THRESHOLD){
        /* Silent correction â€” within tolerance */
        c.worldPos.x=snapped.x; c.worldPos.z=snapped.z;
        snapMoved=true; moved=true;
        constraintQuality.planeSnap=1.0;
      } else if(dist>=RESNAP_THRESHOLD){
        /* Too large â€” flag but don't apply */
        constraintQuality.planeSnap=Math.max(0,1-dist/0.5);
      } else {
        constraintQuality.planeSnap=1.0;
      }
    });
  }

  /* 3. Apply true-North heading constraint from fused compass
        targetYaw = how much to rotate plan in XR space so its top faces North.
        If fusedHeading = H at placement (xrNorthOffset), then XR +Z pointed at
        compass direction H. To make plan-top (UV top) face North (0Â°), we rotate
        by -xrNorthOffset in XR space. As the phone drifts, fusedHeading changes â€”
        we correct by the delta from the original reference.                      */
  if(planBound&&headingLocked&&fusedHeading!=null&&xrNorthOffset!=null){
    var headingDelta=fusedHeading-xrNorthOffset;
    while(headingDelta>180)headingDelta-=360; while(headingDelta<-180)headingDelta+=360;
    /* targetYaw: 0 = plan placed as-is at capture. Negative = rotate toward North. */
    var targetYaw=planYaw-headingDelta*Math.PI/180*0.008;
    var diff=targetYaw-planYaw;
    while(diff>Math.PI)diff-=2*Math.PI; while(diff<-Math.PI)diff+=2*Math.PI;
    planYaw+=diff;
    if(planRigidGroup) planRigidGroup.rotation.y=planYaw;
    moved=true;
  }

  return moved;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   COMPLEMENTARY FILTER â€” HEADING FUSION
   Called from deviceorientation events (set up in startCompass).
   Fuses gyroscope delta (smooth) with compass absolute (stable).
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function updateFusedHeading(compassAbs, alphaRaw, ts){
  if(fusedHeading===null){
    /* Cold start â€” trust compass outright */
    fusedHeading=compassAbs;
    lastAlpha=alphaRaw; lastGyroTime=ts;
    headingLocked=true;
    constraintQuality.compass=0.6;
    return;
  }
  /* Gyro delta: alpha changes at device rotation rate.
     On Android alpha is NOT absolute â€” use delta only.
     Handle wrap-around.                                  */
  var dt=Math.min((ts-lastGyroTime)/1000, 0.1);  /* cap at 100ms */
  var dAlpha=alphaRaw-(lastAlpha||alphaRaw);
  while(dAlpha>180)dAlpha-=360; while(dAlpha<-180)dAlpha+=360;
  lastAlpha=alphaRaw; lastGyroTime=ts;
  gyroRate=dAlpha/Math.max(dt,0.001);

  /* Gyro prediction */
  var gyroPredict=fusedHeading-dAlpha;  /* alpha increases CCW â†’ negate */
  while(gyroPredict<0)gyroPredict+=360; while(gyroPredict>=360)gyroPredict-=360;

  /* Compass wrap-aware blend */
  var compassDiff=compassAbs-gyroPredict;
  while(compassDiff>180)compassDiff-=360; while(compassDiff<-180)compassDiff+=360;
  fusedHeading=gyroPredict+COMPASS_ALPHA*compassDiff;
  while(fusedHeading<0)fusedHeading+=360; while(fusedHeading>=360)fusedHeading-=360;

  headingLocked=true;
  /* Quality: higher if compass and gyro agree */
  var agree=1-Math.abs(compassDiff)/180;
  constraintQuality.compass=0.7*constraintQuality.compass+0.3*agree;

  /* Update GPS bearing reference if we have it */
  if(gpsBearingRef!=null){
    /* Cross-check: if fused heading disagrees with GPS bearing by >15Â°, warn */
    var gpsDiff=Math.abs(fusedHeading-gpsBearingRef.heading);
    while(gpsDiff>180)gpsDiff=360-gpsDiff;
    constraintQuality.gpsBearing=gpsDiff<15?1:Math.max(0,1-gpsDiff/45);
  }

  if(planBound) updateConstraintPanel();
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   GPS BEARING REFINEMENT
   Every time a new GPS fix arrives, push to rolling buffer.
   If two fixes are >2m apart, compute the bearing and store it
   as a reference heading constraint.
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function ingestGPSForBearing(lat,lng,acc){
  if(acc>20) return;  /* only use accurate fixes */
  gpsBearingFixes.push({lat:lat,lng:lng,ts:Date.now()});
  if(gpsBearingFixes.length>8) gpsBearingFixes.shift();
  /* Find pair with largest separation */
  var bestDist=2.0, bestBearing=null;  /* require at least 2m */
  for(var i=0;i<gpsBearingFixes.length-1;i++){
    for(var j=i+1;j<gpsBearingFixes.length;j++){
      var a=gpsBearingFixes[i], b=gpsBearingFixes[j];
      var d=haversineM(a.lat,a.lng,b.lat,b.lng);
      if(d>bestDist){
        bestDist=d;
        bestBearing=bearingDeg(a.lat,a.lng,b.lat,b.lng);
      }
    }
  }
  if(bestBearing!==null){
    /* confidence scales with distance: 2m=0.4, 10m=1.0 */
    var conf=Math.min(1,(bestDist-2)/8*0.6+0.4);
    gpsBearingRef={heading:bestBearing,distance:bestDist,confidence:conf};
    constraintQuality.gpsBearing=conf;
    /* Nudge fused heading toward GPS bearing if confidence is high */
    if(fusedHeading!==null&&conf>0.6){
      var gd=bestBearing-fusedHeading;
      while(gd>180)gd-=360; while(gd<-180)gd+=360;
      fusedHeading+=gd*conf*0.1;
    }
    updateConstraintPanel();
  }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   CONSTRAINT QUALITY PANEL  (updates the statusBar)
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function qualBar(q){
  var n=Math.round(q*5);
  var filled='\u2588'.repeat(n), empty='\u2591'.repeat(5-n);
  return filled+empty;
}
function updateConstraintPanel(){
  if(!planBound)return;
  var lines=[
    'XR  anchors  '+qualBar(constraintQuality.xrAnchor),
    'Compass      '+qualBar(constraintQuality.compass)+(fusedHeading!=null?' '+Math.round(fusedHeading)+'\u00b0':''),
    'GPS bearing  '+qualBar(constraintQuality.gpsBearing)+(gpsBearingRef?' '+Math.round(gpsBearingRef.distance)+'m':''),
    'Plane snap   '+qualBar(constraintQuality.planeSnap),
  ];
  /* Overall lock quality â€” weighted average */
  var overall=(constraintQuality.xrAnchor*0.35+constraintQuality.compass*0.30+
               constraintQuality.gpsBearing*0.15+constraintQuality.planeSnap*0.20);
  var overallStr=overall>0.75?'\u2714 Stable':overall>0.45?'\u26A0 Partial':'\u26D4 Weak';
  el('statusBar').textContent=overallStr+'  \u2022  solve #'+solveCount+'\n'+lines.join('  |  ');
  el('statusBar').style.whiteSpace='pre';
  el('driftBadge').textContent=(overall>0.75?'\u2714':'\u26A0')+' Lock '+Math.round(overall*100)+'%';
  show('driftBadge');
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   WEBXR
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function startWebXR(){
  var canvas=el('arCanvas');
  renderer=new THREE.WebGLRenderer({canvas:canvas,alpha:true,antialias:true});
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth,window.innerHeight);
  renderer.xr.enabled=true;

  scene=new THREE.Scene();
  camera=new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,0.01,200);
  scene.add(new THREE.AmbientLight(0xffffff,1));

  var maxTex=renderer.capabilities.maxTextureSize;
  if(pdfCanvas.width>maxTex||pdfCanvas.height>maxTex){
    var rr=Math.min(maxTex/pdfCanvas.width,maxTex/pdfCanvas.height);
    var tt=document.createElement('canvas');
    tt.width=Math.floor(pdfCanvas.width*rr); tt.height=Math.floor(pdfCanvas.height*rr);
    tt.getContext('2d').drawImage(pdfCanvas,0,0,tt.width,tt.height); pdfCanvas=tt;
  }

  /* Reticle */
  reticle=new THREE.Group(); reticle.matrixAutoUpdate=false; reticle.visible=false;
  var rRing=new THREE.RingGeometry(0.10,0.13,48);
  rRing.applyMatrix4(new THREE.Matrix4().makeRotationX(-Math.PI/2));
  reticle.add(new THREE.Mesh(rRing,new THREE.MeshBasicMaterial({color:0xe84f2b,side:THREE.DoubleSide})));
  var rDot=new THREE.CircleGeometry(0.016,20);
  rDot.applyMatrix4(new THREE.Matrix4().makeRotationX(-Math.PI/2));
  reticle.add(new THREE.Mesh(rDot,new THREE.MeshBasicMaterial({color:0xe84f2b})));
  var lm=new THREE.LineBasicMaterial({color:0xe84f2b,transparent:true,opacity:0.6});
  [[1,0,0],[-1,0,0],[0,0,1],[0,0,-1]].forEach(function(d){
    var lg=new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(d[0]*.04,d[1]*.04,d[2]*.04),new THREE.Vector3(d[0]*.16,d[1]*.16,d[2]*.16)]);
    reticle.add(new THREE.Line(lg,lm));
  });
  scene.add(reticle);

  /* Free plan */
  var asp=pdfCanvas.width/pdfCanvas.height;
  planeGroup=new THREE.Group(); planeGroup.visible=false; scene.add(planeGroup);
  var freeGeo=new THREE.PlaneGeometry(asp,1);
  freeGeo.applyMatrix4(new THREE.Matrix4().makeRotationX(-Math.PI/2));
  var freeTex=new THREE.Texture(pdfCanvas);
  freeTex.needsUpdate=true; freeTex.anisotropy=renderer.capabilities.getMaxAnisotropy();
  freeTex.minFilter=THREE.LinearMipmapLinearFilter; freeTex.magFilter=THREE.LinearFilter; freeTex.generateMipmaps=true;
  planeMesh=new THREE.Mesh(freeGeo,new THREE.MeshBasicMaterial({map:freeTex,transparent:true,opacity:xfOpacity,side:THREE.DoubleSide,depthWrite:false}));
  planeMesh.scale.set(xfScaleM,1,xfScaleM); planeGroup.add(planeMesh);

  /* Session */
  navigator.xr.requestSession('immersive-ar',{
    requiredFeatures:['hit-test'],
    optionalFeatures:['plane-detection','anchors','dom-overlay'],
    domOverlay:{root:el('xrOverlay')}   // â† the FULL overlay div, not just #hud
  }).then(function(session){
    xrSession=session;
    renderer.xr.setReferenceSpaceType('local');
    renderer.xr.setSession(session);
    session.requestReferenceSpace('viewer').then(function(vs){
      session.requestHitTestSource({space:vs}).then(function(src){xrHitTestSrc=src;});
    });
    session.requestReferenceSpace('local').then(function(rs){
      xrRefSpace=rs;
      renderer.setAnimationLoop(function(t,frame){xrFrame(frame);});
    });

    /* Hold-to-place state for anchor mode */
    var holdTimer=null, holdStartPos=null, holdProgress=0;
    var HOLD_MS=600;  /* ms to hold before anchor commits */

    /* Reticle hold-ring overlay â€” drawn in xrFrame */
    var holdRingMat=new THREE.LineBasicMaterial({color:0x2be87a,linewidth:2});
    var holdRingGeo=new THREE.BufferGeometry();
    var holdRingPts=[];
    for(var hi=0;hi<=64;hi++) holdRingPts.push(new THREE.Vector3(Math.cos(hi/64*Math.PI*2)*0.12,0.005,Math.sin(hi/64*Math.PI*2)*0.12));
    holdRingGeo.setFromPoints(holdRingPts.slice(0,1));
    var holdRing=new THREE.Line(holdRingGeo,holdRingMat);
    holdRing.visible=false; scene.add(holdRing);

    function commitAnchor(rx,ry,rz){
      if(corners.length>=MAX_CORNERS){el('hudHint').textContent='Max '+MAX_CORNERS+' column anchors reached';return;}
      var fp=currentSnap?{x:currentSnap.x,y:currentSnap.y,z:currentSnap.z}:{x:rx,y:ry,z:rz};
      /* Capture GPS alongside XR anchor */
      var corner={
        worldPos:fp, anchor:null,
        gps: gpsLat!=null ? {lat:gpsLat, lng:gpsLng, acc:gpsAcc} : null
      };
      corners.push(corner);
      addCornerVisual(fp,corners.length-1);
      updateCornerBadge();
      el('hudHint').textContent=currentSnap?'Column '+corners.length+' \u2014 snapped \u2713':'Column '+corners.length+' anchored';

      /* Auto-drop GPS waypoint if we have a fix */
      if(corner.gps && gpsLat!=null){
        var idx=waypoints.length;
        var col=CORNER_COLORS[idx%CORNER_COLORS.length];
        var dot3=new THREE.Mesh(new THREE.SphereGeometry(0.04,10,10),new THREE.MeshBasicMaterial({color:col}));
        dot3.position.set(fp.x,fp.y+0.04,fp.z); scene.add(dot3);
        var lbl=document.createElement('div');
        lbl.className='wp-label';
        lbl.textContent='C'+(idx+1)+' \u00b1'+Math.round(gpsAcc||99)+'m';
        var hexCol='#'+col.toString(16).padStart(6,'0');
        lbl.style.background=hexCol; lbl.style.color=col>0x888888?'#04050f':'#fff';
        el('wpLabels').appendChild(lbl);
        waypoints.push({id:idx+1,gps:corner.gps,world:{x:fp.x,y:fp.y,z:fp.z},dot:dot3,labelEl:lbl});
        renderMiniMap();
      }

      /* XRAnchor */
      if(typeof session.createAnchor==='function'){
        try{
          var cidx=corners.length-1;
          session.createAnchor(new XRRigidTransform(new DOMPointReadOnly(fp.x,fp.y,fp.z,1),new DOMPointReadOnly(0,0,0,1)),xrRefSpace)
            .then(function(a){corners[cidx].anchor=a;}).catch(function(){});
        }catch(e){}
      }

      /* If plan is already bound, re-solve with new anchor */
      if(planBound) reSolvePlan();
    }

    /* SELECT start â€” begin hold timer */
    session.addEventListener('selectstart',function(){
      if(!reticle.visible)return;
      if(!traceMode) return;  /* hold only applies to anchor mode */
      holdStartPos={
        x:reticle.matrix.elements[12],
        y:reticle.matrix.elements[13],
        z:reticle.matrix.elements[14]
      };
      holdProgress=0;
      holdTimer=setTimeout(function(){
        /* Held long enough â€” commit */
        holdTimer=null; holdProgress=0; holdRing.visible=false;
        if(holdStartPos && reticle.visible){
          commitAnchor(holdStartPos.x,holdStartPos.y,holdStartPos.z);
        }
        holdStartPos=null;
      }, HOLD_MS);
    });

    /* SELECT end â€” if released before hold time, cancel */
    session.addEventListener('selectend',function(){
      if(holdTimer){ clearTimeout(holdTimer); holdTimer=null; }
      holdStartPos=null; holdProgress=0; holdRing.visible=false;
    });

    /* SELECT (instant tap) â€” used for placement and measure only */
    session.addEventListener('select',function(){
      if(!reticle.visible)return;
      var rx=reticle.matrix.elements[12],ry=reticle.matrix.elements[13],rz=reticle.matrix.elements[14];

      /* MEASURE MODE â€” instant tap ok */
      if(measureMode){
        var fp=currentSnap?{x:currentSnap.x,y:currentSnap.y,z:currentSnap.z}:{x:rx,y:ry,z:rz};
        if(!measurePt1){
          measurePt1=fp;
          var dot=new THREE.Mesh(new THREE.SphereGeometry(0.028,10,10),new THREE.MeshBasicMaterial({color:0xf0d060}));
          dot.position.set(fp.x,fp.y+0.028,fp.z); scene.add(dot); measureDots.push(dot);
          el('hudHint').textContent='Tap floor for point 2\u2026';
        } else {
          measurePt2=fp;
          buildMeasureLine(measurePt1,measurePt2);
          updateMeasureLabel(measurePt1,measurePt2);
          measurePt1=null; measurePt2=null;
          el('hudHint').textContent='Tap to measure again or Done';
        }
        return;
      }

      /* ANCHOR MODE â€” handled by hold, not instant tap */
      if(traceMode) return;

      /* INITIAL PLACEMENT â€” instant tap */
      if(wxrPlaced)return;
      var q=new THREE.Quaternion();
      new THREE.Matrix4().fromArray(reticle.matrix.elements).decompose(new THREE.Vector3(),q,new THREE.Vector3());
      planeGroup.position.set(rx,ry,rz); planeGroup.quaternion.copy(q); planeGroup.visible=true;
      surfaceQuat.copy(q); wxrPlaced=true;
      floorPlane.setFromNormalAndCoplanarPoint(new THREE.Vector3(0,1,0).applyQuaternion(q).normalize(),new THREE.Vector3(rx,ry,rz));
      if(fusedHeading!=null) xrNorthOffset=fusedHeading;
      applyFree(); hide('scanRing');
      xfLocked=true; el('lockBtn').textContent='\uD83D\uDD12 Locked'; el('lockBtn').className='hud-btn g';
      onPlanPlaced();
    });

    /* Update hold ring arc each frame */
    function updateHoldRing(frame){
      if(!holdTimer||!holdStartPos||!traceMode){ holdRing.visible=false; return; }
      holdProgress=Math.min(1,(Date.now()-(Date.now()-HOLD_MS)-0)/HOLD_MS);
      /* Simpler: derive from time elapsed since selectstart */
      /* We'll track startTime on the holdStartPos object */
      if(!holdStartPos._t) holdStartPos._t=Date.now();
      var elapsed=Date.now()-holdStartPos._t;
      var frac=Math.min(1,elapsed/HOLD_MS);
      var nPts=Math.max(2,Math.round(frac*64));
      var pts2=[];
      for(var hi=0;hi<=nPts;hi++) pts2.push(holdRingPts[Math.min(hi,63)]);
      holdRingGeo.setFromPoints(pts2);
      holdRingGeo.attributes.position.needsUpdate=true;
      holdRing.position.set(holdStartPos.x,holdStartPos.y,holdStartPos.z);
      holdRing.visible=true;
      /* Flash green when complete */
      holdRingMat.color.setHex(frac>=1?0xffffff:0x2be87a);
    }

    /* Touch pan / pinch */
    var tMap={},panRC=new THREE.Raycaster(),panTgt=new THREE.Vector3();
    window.addEventListener('touchstart',function(e){for(var i=0;i<e.changedTouches.length;i++){var t=e.changedTouches[i];tMap[t.identifier]={x:t.clientX,y:t.clientY};}},{passive:true});
    window.addEventListener('touchmove',function(e){
      if(!wxrPlaced||traceMode||boundMesh)return;
      for(var i=0;i<e.changedTouches.length;i++){var t=e.changedTouches[i];tMap[t.identifier]={x:t.clientX,y:t.clientY};}
      var pts=Object.values(tMap);
      if(pts.length===1&&!xfLocked){
        var pt=pts[0];
        panRC.setFromCamera({x:(pt.x/window.innerWidth)*2-1,y:-((pt.y/window.innerHeight)*2-1)},camera);
        if(panRC.ray.intersectPlane(floorPlane,panTgt)){planeGroup.position.copy(panTgt);floorPlane.setFromNormalAndCoplanarPoint(floorPlane.normal,panTgt);}
        return;
      }
      if(pts.length>=2){
        var a=pts[0],b=pts[1],dx=b.x-a.x,dy=b.y-a.y;
        var dist=Math.sqrt(dx*dx+dy*dy),ang=Math.atan2(dy,dx);
        if(prevPinchDist!==null){
          xfScaleM=Math.max(0.05,Math.min(500,xfScaleM*(dist/prevPinchDist)));
          /* Scale the free plan mesh group, not planeMesh directly */
          if(planeMesh)planeMesh.scale.set(xfScaleM,1,xfScaleM);
          else if(planeGroup)planeGroup.scale.set(xfScaleM,1,xfScaleM);
          var da=ang-prevPinchAngle; while(da>Math.PI)da-=2*Math.PI; while(da<-Math.PI)da+=2*Math.PI;
          xfRotY-=da; applyFree();
        }
        prevPinchDist=dist; prevPinchAngle=ang;
      }
    },{passive:true});
    window.addEventListener('touchend',function(e){for(var i=0;i<e.changedTouches.length;i++)delete tMap[e.changedTouches[i].identifier];if(Object.keys(tMap).length<2){prevPinchDist=null;prevPinchAngle=null;}},{passive:true});

    session.addEventListener('end',function(){renderer.setAnimationLoop(null);});
    show('scanRing');
    el('hudHint').textContent='Slowly scan the ground\u2026';
    /* Auto-align to compass heading on first surface detection if available */
    if(compassHeading!=null){ xfRotY=compassHeading*Math.PI/180; }

  }).catch(function(err){el('hudHint').textContent='AR error: '+err.message;console.error(err);});
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   XR FRAME LOOP
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function xrFrame(frame){
  if(!frame)return;
  renderer.render(scene,camera);

  /* Update measure label position (project to screen each frame) */
  if(measureLine&&camera){
    var ma=measureLine.geometry.attributes.position;
    if(ma&&ma.count>=2){
      var wA={x:ma.getX(0),y:ma.getY(0)+0.04,z:ma.getZ(0)};
      var wB={x:ma.getX(1),y:ma.getY(1)+0.04,z:ma.getZ(1)};
      updateMeasureLabel(wA,wB);
    }
  }

  /* Update GPS waypoint label screen positions */
  updateWaypointLabels();

  /* Update hold ring for anchor placement */
  if(typeof updateHoldRing==='function') try{updateHoldRing(frame);}catch(e){}

  /* Update plane wireframes */
  if(xrRefSpace){
    try{updatePlaneWireframes(frame,xrRefSpace);}catch(e){}
  }

  if(!xrHitTestSrc||!xrRefSpace)return;
  var hits=frame.getHitTestResults(xrHitTestSrc);
  if(hits.length>0){
    var pose=hits[0].getPose(xrRefSpace);
    reticle.visible=true;
    reticle.matrix.fromArray(pose.transform.matrix);

    var hitPos=new THREE.Vector3(pose.transform.position.x,pose.transform.position.y,pose.transform.position.z);

    /* Plane snap during tracing */
    if(traceMode){
      var snapped=snapToNearestPlaneVertex(hitPos,frame,xrRefSpace);
      if(snapped){
        currentSnap=snapped;
        reticle.matrix.elements[12]=snapped.x;
        reticle.matrix.elements[13]=snapped.y;
        reticle.matrix.elements[14]=snapped.z;
        show('snapIndicator');
        el('snapCircle').setAttribute('stroke','#2be87a'); el('snapV').setAttribute('stroke','#2be87a');
        el('snapH').setAttribute('stroke','#2be87a'); el('snapDot').setAttribute('fill','#2be87a');
      }else{
        currentSnap=null; hide('snapIndicator');
        el('snapCircle').setAttribute('stroke','#4da6ff'); el('snapV').setAttribute('stroke','#4da6ff');
        el('snapH').setAttribute('stroke','#4da6ff'); el('snapDot').setAttribute('fill','#4da6ff');
      }
    }

    if(!wxrFloorFound){
      wxrFloorFound=true; show('planeBadge');
      el('hudHint').textContent=traceMode?'Walk to column base and tap':'Tap to place plan';
      setTimeout(function(){hide('planeBadge');},4000);
    }
  }else{
    reticle.visible=false; currentSnap=null;
    if(traceMode)hide('snapIndicator');
    if(!wxrPlaced){wxrFloorFound=false; el('hudHint').textContent='Slowly scan the ground\u2026';}
  }

  /* Anchor drift correction + full constraint fusion */
  if(planBound&&corners.length>0){
    if(updateAnchors(frame,xrRefSpace)){
      reSolvePlan();
    }
  }
}

})();
</script>
</body>
</html>
